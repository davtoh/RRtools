# -*- coding: utf-8 -*-
"""
some quick concepts:

thresholds: https://en.wikipedia.org/wiki/Thresholding_(image_processing)
    unimodal: https://en.wikipedia.org/wiki/Unimodal_thresholding
    techniques : http://pequan.lip6.fr/~bereziat/pima/2012/seuillage/sezgin04.pdf
    useful functions: http://docs.opencv.org/2.4/modules/imgproc/doc/miscellaneous_transformations.html
Region growing: https://en.wikipedia.org/wiki/Region_growing
    use: cv2.floodFill, cv2.watershed
    watershed: https://en.wikipedia.org/wiki/Watershed_(image_processing)
    watershed example: http://docs.opencv.org/3.1.0/d3/db4/tutorial_py_watershed.html#gsc.tab=0
"""
__author__ = 'Davtoh'

import sys
from RRtoolbox.lib.root import Controlstdout, stdoutSIM, stdoutLOG

import cv2
import matplotlib.animation as animation
import matplotlib.pyplot as plt
import numpy as np
from RRtoolbox.lib.arrayops.basic import convertXY,overlayXY, padVH,overlay, normalize,\
    standarizePoints,anorm,vectorsAngles,isnumpy, histogram, findminima,findmaxima,find_near, \
    getOtsuThresh, anorm2
from RRtoolbox.tools.selectors import entropy
from RRtoolbox.lib.arrayops.filters import smooth,normsigmoid,sigmoid,filterFactory,bilateralFilter,FilterBase
from RRtoolbox.lib.arrayops.convert import getSOpointRelation, spoint2opointfunc, sh2oh,contour2points,points2contour
from RRtoolbox.lib.directory import directory,getData
from RRtoolbox.lib.plotter import plotim,edger,plotPointsContour,graph_filter
from RRtoolbox.lib.image import getcoors,drawcoorperspective, imcoors
from RRtoolbox.lib.arrayops.mask import brightness, biggestCntData, biggestCnt, thresh_biggestCnt, gethull
from RRtoolbox.lib.directory import getData
from RRtoolbox.lib.root import sleep

base = "/mnt/4E443F99443F82AF/MEGAsync/"#"/media/davtoh/DavtohDisk1/Davtoh/University/"
IMAGEPATH = directory(base+"TESIS/DATA_RAW/IMAGES")
SAVETO = directory(base+"TESIS/DATA_PROCESSED/Tests")

def printParams(params, header = True, epilog = True, width = 100):
    """
    print dictionary parameters.

    :param params: dictionary generated by globals() or locals()
    :param header: if True uses header or if string uses it.
    :param epilog: if True uses epilog or if string uses it.
    :param width: header and epilog width
    :return:
    """
    if header is True:
        header="These Are The Parameters:".center(width,"*")
    if header: print header
    for key,val in params.items():
        print "{}: {}".format(key,val)
    if epilog is True:
        epilog="*"*width
    if epilog: print epilog

def correctString(string, includeSpaces = True, replace = None):
    """
    Changes invalid characters.

    :param string: str
    :param includeSpaces: if True string includes spaces, else suppress them
    :param replace: use replace character for invalid
    :return: corrected string
    """
    parts = []
    for e in string:
        if e.isalnum():
            parts.append(e)
        elif includeSpaces and e==" ":
            parts.append(e)
        elif replace:
            parts.append(replace)
    return ''.join(parts)

def hist_cdf(img,window_len=0,window='hanning'):
    """
    get image histogram and the normalized cumulative distribution function.

    :param img: imaeg
    :param window_len:
    :param window:
    :return: histogram (int), normalized cdf (float)
    """
    hist,bins = np.histogram(img.flatten(),256,[0,256])
    if window_len: hist = smooth(hist,window_len,window) # if window_len=0 => no filter
    cdf = hist.cumsum() # cumulative distribution function
    cdf_normalized = cdf*float(hist.max())/cdf.max() #normalized cdf
    return hist,cdf_normalized

def animateSimoid(alfas,betas,x=None,interval=1000,show=True,frames=None):
    """
    Show sigmoid filter or animation of it if alfas or betas are iterable.

    :param alfas: array of alfa values or alfa value
    :param betas: array of beta values or beta value
    :param x: array of values or matrix to filter
    :param interval: time in millisecond of each update
    :return: None
    #example1:
    alfas = 10
    betas = np.linspace(0,256,256)
    simulateSimoid(alfas,betas)
    #example2:
    import cv2
    grayim = cv2.imread("asift2fore.png",0).astype("float")
    ani = simulateSimoid(125,np.linspace(0, 10, 13),grayim,100,show=False)
    ani.save('sigmoid.gif', fps=1)
    """
    if x is None:
        x = np.linspace(0, 255, 256)
    else:
        x = np.array(x,dtype=np.float)
    alfas = np.array(alfas,dtype=np.float)
    betas = np.array(betas,dtype=np.float)
    fig, ax = plt.subplots()
    # correct arrays
    if not len(alfas.shape): alfas = np.array((alfas,),dtype=np.float)
    if not len(betas.shape): betas = np.array((betas,),dtype=np.float)
    alfas[alfas==0]=0.01 # replacing 0 for aproximation
    if len(x.shape) == 1:  # if x is array
        ax_minx,ax_maxx = np.min(x),np.max(x) # control x axis
        ax_miny,ax_maxy = -1.5,1.5 # control y axis
        ax.hold(False) # plot replaces previous plots
        title = 'Sigmoid Filter: x = ['+str(ax_minx)+'-'+str(ax_maxx)+']'
        def updatefig(*args):
            args[1][0] = (args[1][0]+1)%len(alfas) # increase alfas index
            if args[1][0] ==0: # increase beta index
                args[1][1] = (args[1][1]+1)%len(betas)
            ax.plot(x, normsigmoid(x,alfas[args[1][0]],betas[args[1][1]]))
            ax.axis([ax_minx, ax_maxx, ax_miny, ax_maxy]) # set axis dimensions
            ax.set_title(title)
            ax.text(0, -1, ' alfa='+str(alfas[args[1][0]])+', beta='+str(betas[args[1][1]])) # set text
            return ax,
    else:  # if x is matrix array
        im = plt.imshow(normsigmoid(x,alfas[0],betas[0]), cmap=plt.get_cmap('jet'))
        title = 'Sigmoid Filter: x = '+str(x.shape)
        title_obj = plt.title(title) # plt.getp(title_obj)
        plt.colorbar()
        def updatefig(*args):
            args[1][0] = (args[1][0]+1)%len(alfas) # increase alfas index
            if args[1][0] ==0: # increase beta index
                args[1][1] = (args[1][1]+1)%len(betas)
            plt.setp(title_obj,text = title+', alfa='+str(alfas[args[1][0]])+', beta='+str(betas[args[1][1]])) # set title
            im.set_array(normsigmoid(x,alfas[args[1][0]],betas[args[1][1]]))
            plt.draw() # update plt title after image is shown
            return im,

    ab= np.array([-2,0])
    if frames is None:
        frames = len(alfas)*len(betas)
    ani = animation.FuncAnimation(fig, updatefig, frames, interval=interval, blit=True,fargs=[ab])
    if show: plt.show()
    return ani

def graphHistogram(img, show=True, size=None, hold=True):
    """
    Graph histogram from image.

    :param img: gray or BGR image
    :param show: if show in window
    :param size: size of image to get
    :param hold: if use hold on a previous plt figure
    :return: figure
    """
    if not hold: plt.figure()
    sz = img.shape
    if len(sz)==2:
        histr = cv2.calcHist([img],[0],None,[256],[0,256])
        plt.plot(histr,color = "k")
        plt.xlim([0,256])
    else:
        color = ('b','g','r')
        for i,col in enumerate(color):
            histr = cv2.calcHist([img],[i],None,[256],[0,256])
            plt.plot(histr,color = col)
            plt.xlim([0,256])
    fig = plt.gcf()
    if size is not None: fig.set_size_inches(*size)
    if show: plt.show()
    return fig

def graphmath(y, colors= None, linedic={'ls': '-'}, win=None, title=None, show=True):
    """
    Plots data.

    :param y: data to plot in y axis (x is its index)
    :param colors: list of colors for each y index
    :param linedic: line properties
    :param win: window title, if it is not None creates a figure.
    :param title: plot title
    :param show: if True, shows; Fase, only builds plot
    :return: figure, lines
    """
    #http://matplotlib.org/users/pyplot_tutorial.html
    if not isinstance(y,(tuple,list)): y = [y]
    if win is not None: plt.figure(win)
    if title is not None: plt.title(title)
    lines = []
    for i,axisy in enumerate(y):
        if colors is None:
            line = plt.plot(axisy)
        else:
            line = plt.plot(axisy,colors[i])
        lines.extend(line)
        plt.setp(line,**linedic)
    #plt.xlim([0,256])
    fig = plt.gcf()
    if show: plt.show()
    return fig, lines

def stem(x,y,color):
    """
    plot a stem in plot.

    :param x: x coordinate
    :param y: y coordinate
    :param color: the color of the stem
    :return: None
    """
    # remainder of how to plot stems in matplotlib
    markerline, stemlines, baseline = plt.stem(x,y,linefmt='b-', markerfmt='bo', basefmt='r-')
    plt.setp(stemlines, linewidth=1, color = color)     # set stems
    plt.setp(markerline, 'markerfacecolor', color)    # make points

def getthresh(gray):
    """
    Get best possible thresh to threshold object from the gray image.

    :param gray: gray image
    :return: thresh value
    """
    hist,cdf = hist_cdf(gray,11)
    th1 = 130 #np.min(np.where(cdf.max()*0.2<=cdf))
    th2 = np.max(np.where(hist.max()==hist))
    th3 = np.min(np.where(np.mean(cdf)<=cdf))
    #th4=findminima(hist,np.mean([th1,th2,th3]))
    return np.mean([th1,th2,th3])

def threshold(src, thresh, maxval=255, type=cv2.THRESH_BINARY):
    """
    Eliminate small objects from threshold.

    :param src:
    :param thresh:
    :param maxval:
    :param type:
    :return:
    """
    from recommended import getKernel
    shape = src.shape
    kernel = getKernel(shape[0]*shape[1])
    #ks = kernel.shape[0]/3 # kenerl size?
    #kz = np.mean(src.shape)/50
    #kernel = np.ones((kz,kz),np.uint8)
    retval,th = cv2.threshold(src, thresh, maxval, type)
    th = cv2.morphologyEx(th, cv2.MORPH_OPEN, kernel)
    return th

def pad(im,pad_val,pad_width=1,expand = False):
    """
    Fills borders with given value.

    :param im: numpy array
    :param pad_val: value to use
    :param pad_width: border width
    :param expand:
    :return:
    """
    if expand:
        w,h = im.shape[0:2]
        padding = pad_width*2
        if len(im.shape)>2:
            back = np.ones((w+padding,h+padding,im.shape[2]),np.uint8)
        else:
            back = np.ones((w+padding,h+padding),np.uint8)
        x,y= convertXY(0,0,back.shape,im.shape,flag=4)
        im = overlayXY(x,y,back,im)

    im[0:pad_width,:] = pad_val
    im[:,0:pad_width] = pad_val
    im[-1:-1-pad_width:-1,:] = pad_val
    im[:,-1:-1-pad_width:-1] = pad_val
    return im

def croppad(im,pad_width=0):
    """

    :param im:
    :param pad_width:
    :return:
    """
    if pad_width:
        return im[pad_width:-pad_width,pad_width:-pad_width]
    return im

def retinalmask(gray,invert = False):
    """
    Mask of a ellipse enclosing retina.

    :param gray: gray image
    :param invert: invert mask
    :return: mask
    """
    thresh = getthresh(gray) # obtain optimus threshold
    rough_mask=threshold(gray,thresh,1,0)
    contours,hierarchy = cv2.findContours(rough_mask,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)
    index,maxarea = 0,0
    for i in xrange(len(contours)):
        area = cv2.contourArea(contours[i])
        if area>maxarea: index,maxarea = i,area
    cnt = contours[index]
    ellipse = cv2.fitEllipse(cnt)
    if invert:
        mask = np.ones(gray.shape,dtype=np.uint8)
        cv2.ellipse(mask,ellipse,0,-1)
    else:
        mask = np.zeros(gray.shape,dtype=np.uint8)
        cv2.ellipse(mask,ellipse,1,-1)
    return mask

def circularMask(shape, radious = None, center=None):
    """

    :param shape:
    :param radious:
    :param center:
    :return:
    """
    # http://stackoverflow.com/a/8650741/5288758
    sa,sb = shape[:2]
    if center is None:
        a,b = sa//2,sb//2
    else:
        a, b = center
    if radious is None: radious = (sa+sb)//4
    y,x = np.ogrid[-a:sa-a, -b:sb-b]
    return x**2 + y**2 <= radious**2

def circularKernel(shape, dtype= None, radious = None, center=None, fillwith = 1):
    """

    :param shape:
    :param dtype:
    :param radious:
    :param center:
    :param fillwith:
    :return:
    """
    # http://stackoverflow.com/a/8650741/5288758
    mask = circularMask(shape=shape,radious=radious,center=center)
    array = np.zeros(mask.shape,dtype=dtype)
    array[mask] = fillwith
    return array

def simulateLens(img, scaled_shape = (300,300), parameters = (10,30,None),color = 0):
    """
    Place lens-like object in image.

    :param img: image to place lens
    :param scaled_shape: shape to resize processing image to increase performance
    :param parameters: for internal process used to filter image when getting brightness
    :param color: color of the lens
    :return: image with simulated lens
    """
    sz = img.shape[0:2] # get original image size
    scalepoints = spoint2opointfunc(sz,scaled_shape) # make rescaling function: scaled point -to- original point function
    scaled_img = cv2.resize(img,scaled_shape) # resize to scaled image
    fore2 = scaled_img.copy()

    if parameters is not None:
        myfilter = filterFactory(*parameters) # alfa,beta1,beta2
        fore2=myfilter(fore2.astype("float"))*255#*fore.astype("float")
        fore2 = fore2.astype("uint8")

    P = brightness(fore2) # get scaled image brightness
    thresh,sure_bg = cv2.threshold(P,0,1,cv2.THRESH_BINARY+cv2.THRESH_OTSU) # obtain over threshold
    thresh,sure_fg = cv2.threshold(P,thresh+10,1,cv2.THRESH_BINARY)

    markers = np.ones_like(sure_fg).astype("int32") # make background markers
    markers[sure_bg==1]=0 # mark unknown markers
    markers[sure_fg==1]=2 # mark sure object markers

    cv2.watershed(scaled_img,markers) # get watershed on markers

    thresh,lastthresh = cv2.threshold(markers.astype("uint8"),1,1,cv2.THRESH_BINARY) # get binary image of contour
    # find biggest area and contour
    contours,hierarchy = cv2.findContours(lastthresh,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)
    index = 0
    maxarea = 0
    for i in xrange(len(contours)):
        area = cv2.contourArea(contours[i])
        if area>maxarea:
            index = i
            maxarea = area
    cnt = contours[index]
    cnt2 = np.int32(scalepoints(cnt)) # rescale contour to original image contour
    ellipse = cv2.fitEllipse(cnt2) # get ellipse for original image to simulate lens
    mask = np.ones(sz,dtype=np.uint8) # create mask
    cv2.ellipse(mask,ellipse,0,-1) # project lens over mask
    # simulate lens
    img[mask>0]=color # use mask to project black color over original image
    return img,mask

def simulateLens_approx(img, scaled_shape = (300,300), color = 0):
    """
    Place lens-like object in image.

    :param img: image to place lens
    :param scaled_shape: shape to resize processing image to increase performance
    :param parameters: for internal process used to filter image when getting brightness
    :param color: color of the lens
    :return: image with simulated lens
    """
    sz = img.shape[0:2] # get original image size
    if scaled_shape is None:
        P = brightness(img)
    else:
        P = brightness(cv2.resize(img,scaled_shape)) # get scaled image brightness
    thresh,lastthresh = cv2.threshold(P,0,1,cv2.THRESH_BINARY+cv2.THRESH_OTSU)
    cnt = CircleClosure(lastthresh)
    if scaled_shape is not None:
        scalepoints = spoint2opointfunc(sz,scaled_shape) # make rescaling function: scaled point -to- original point function
        cnt = np.int32(scalepoints(cnt)) # rescale contour to original image contour
    ellipse = cv2.fitEllipse(cnt) # get ellipse for original image to simulate lens
    mask = np.ones(sz,dtype=np.uint8) # create mask
    cv2.ellipse(mask,ellipse,0,-1) # project lens over mask
    # simulate lens
    img[mask>0]=color # use mask to project black color over original image
    return img,mask

def getalfa(foregray,backgray,window = None):
    """
    Get alfa transparency for merging to retinal images.

    :param foregray: image on top
    :param backgray: image at bottom
    :param window: window used to customizing alfa, values go from 0 for transparency to any value
                    where the maximum is visible i.e a window with all the same values does nothing.
                    a binary image can be used, where 0 is transparent and 1 is visible.
                    If not window is given alfa is left as intended.
    :return: float window modified by alfa
    """
    backmask = normalize(normsigmoid(backgray,10,180)+normsigmoid(backgray,3.14,192)+normsigmoid(backgray,-3.14,45))
    foremask = normalize(normsigmoid(foregray,-1,242)*normsigmoid(foregray,3.14,50))
    foremask = normalize(foremask * backmask)
    foremask[foremask>0.9] = 2.0
    ksize = (21,21)
    foremask = normalize(cv2.blur(foremask,ksize))
    if window is not None: foremask *= normalize(window)
    return foremask

def equalization(img):
    """
    Histogram equalization of an image as in:

        http://docs.opencv.org/doc/tutorials/imgproc/histograms/histogram_equalization/histogram_equalization.html

    :param img: image
    :return: equalized image, cdf (cumulative distribution function)
    """
    # http://docs.opencv.org/3.1.0/d5/daf/tutorial_py_histogram_equalization.html#gsc.tab=0
    # get hist and cdf from img
    hist,bins = np.histogram(img.flatten(),256,[0,256])
    cdf = hist.cumsum()
    # get equalized img in img2
    cdf_m = np.ma.masked_equal(cdf,0) # masking to leave out 0
    cdf_m = (cdf_m - cdf_m.min())*255/(cdf_m.max()-cdf_m.min()) # applying equalization
    cdf = np.ma.filled(cdf_m,0).astype('uint8') # cumulative distribution function
    return cdf[img], cdf


def getColors(im, coors=None):
    """
    Get coordinates' colors.

    :param im: image to get colors form coors.
    :param coors: coordinates of points.
    :return:
    """
    if coors is None: coors = getcoors(im)
    return [im[cor[1],cor[0]] for cor in coors]


def getColorsRange(im, coors=None):
    """
    get max and min values of colors in coordinates.

    :param im: image to get colors form coors.
    :param coors: coordinates of points.
    :return: max color, min color range
    """
    colors = getColors(im, coors)
    maxC,minC = np.max(colors,0),np.min(colors,0)
    return maxC,minC


def rColor(channels = 1, min=0, max=256):
    """
    Random color.

    :param channels: number of channels
    :param min: min color in any channel
    :param max: max color in any channel
    :return: random color
    """
    return [np.random.randint(min,max) for i in xrange(channels)]


def drawContours(mask, contours, min=50, max=256):
    """
    draw contours in mask.

    :param mask: mask to draw
    :param contours: contours
    :param min: min color range
    :param max: max color range
    :return: drawn mask
    """
    if len(mask.shape) > 2:
        ch = mask.shape[2]
    else:
        ch = 1
    for i in xrange(len(contours)):
        cv2.drawContours(mask,contours,i,rColor(ch,min,max),2)
    return mask

def graphDeffects(img,cnt,defects,cline=(0,255,0),cpoint=(0,0,255),thickness=2, alfa=None):
    """
    Graphs convexity defects.

    :param img: source BGR image
    :param cnt: contour
    :param defects: convexity defects
    :param cline: line's color
    :param cpoint: points' colors
    :return: processed img
    """
    if alfa is not None:
        temp,img = img,np.zeros_like(img)
        imalfa = np.zeros(img.shape[:2])
    for i in range(defects.shape[0]):
        s,e,f,d = defects[i,0]
        start = tuple(cnt[s][0])
        end = tuple(cnt[e][0])
        far = tuple(cnt[f][0])
        cv2.line(img,start,end,cline,thickness)
        cv2.circle(img,far,thickness,cpoint,-1)
        if alfa is not None:
            cv2.line(imalfa,start,end,1,thickness)
            cv2.circle(imalfa,far,thickness,1,-1)
    if alfa is None:
        return img
    return overlay(temp, img, alpha=imalfa * alfa)

def twoMaxTest(defects,epsilon=0.5):
    """
    Filters distances from defects.

    :param defects:
    :param epsilon:
    :return:
    """
    distances = defects[:,0,3]
    two_max = np.argpartition(distances, -2)[-2:] # get indeces of two maximum values
    d1,d2 = distances[two_max[0]],distances[two_max[1]]*epsilon
    if d1>d2:
        return True
    else:
        return False

def separatingLine(cnt,defects):
    """
    Gets start and end points of separating line of deepest convexity defects.

    :param cnt: contour
    :param defects: convexity defects
    :return: start, end
    """
    positions = defects[:,0,2] # get positions
    distances = defects[:,0,3] # get its distances from hull
    two_max = np.argpartition(distances, -2)[-2:] # get indexes of two maximum distances
    point1 = tuple(cnt[positions[two_max[0]]][0]) # get point a one side
    point2 = tuple(cnt[positions[two_max[1]]][0]) # get point at the other side
    return point1,point2

def extendedSeparatingLine(shape, cnt, defects):
    """
    Get start and end points of separating line of deepest convexity defects extended to shape corners.

    :param shape: (x,y)
    :param cnt: contour
    :param defects: convexity defects
    :return: start, end
    """
    return extendLine(shape,*separatingLine(cnt, defects)) # extend the two points to the corners of the shape

def extendLine(shape,point1,point2):
    """
    extends a line passing by point 1 and 2 to reach shape borders.

    :param shape:
    :param point1:
    :param point2:
    :return:
    """
    h,w = shape[0:2]
    x1,y1 = point1
    x2,y2 = point2
    m = (y2-y1)/float(x2-x1)
    if m != float:
        if x1==x2: # vertical line
            start = x1,0
            end = x1,h
            return start,end
        if y1==y2: # horizontal line
            start = 0,y1
            end = w,y1
            return start,end
        return (x1,y1),(x2,y2) # unknown case, return "as it"
    # calculate using equation
    b = int(y1-x1*m)
    # find interception with xf and yf axis
    if b>h: # if start outside yf
        start = int((h-b)/m),h # (yf-b)/m, yf
    else: # if start inside yf
        start = 0,b # 0,y
    y = int(m*w+b) # m*xf+b
    if y<0: # if end outside yf
        end = int(-b/m),0# x,0
    else: # if end inside yf
        end = w,y # xf, y
    return start,end # return extended line to image border

def colorpolygontest(res):
    """
    Get from polygontest a BGR color version.

    """
    # TO SPEED UP
    res = np.int0(np.around(res))
    mini = res.min()
    if not mini: mini = -1
    minie = 255.0/mini
    maxi = res.max()
    if not maxi: maxi = 1
    maxie = 255.0/maxi

    drawing = np.zeros((maxi-mini+1,3),np.uint8)  # image to draw the distance
    # correct res by adding minimum distance to res it is shifted to 0
    if mini<0:
        res += abs(mini)
    else:
        res -= mini
    #define the colors
    for h,i in enumerate(xrange(mini,maxi+1)):
        if i<0:
            drawing.itemset((h,0),255-int(minie*i))
        elif i>0:
            drawing.itemset((h,2),255-int(maxie*i))
        else:
            drawing[h]=[255,255,255]

    return drawing[res] # appy pallete

def _polygontest(src,cnt):
    """
    Draws polygontest in image from contour. (Helper function for polygontest)

    :param src: source binary image of int32
    :param cnt: contour
    :return: calculated polygon test in src
    """
    rows,cols = src.shape[0:2]
    for i in xrange(rows):# Calculate distance from each point
        for j in xrange(cols):
            src.itemset((i,j),cv2.pointPolygonTest(cnt,(j,i),True))
    return src

def center_polygontest(cnt,center):
    """
    Polygon tests from contour and center.

    :param cnt: contour
    :param center: (x,y)
    :return: array of tests
    """
    tempcnt = np.array([[center]])
    return np.absolute([cv2.pointPolygonTest(tempcnt,(i[0,0],i[0,1]),True) for i in cnt])

def center_distances(cnt,center):
    """
    Distances from contour and center.

    :param cnt: contour
    :param center: (x,y)
    :return: array of distances
    """
    return np.sqrt(np.sum(np.power(cnt-center,2),2)) # array.anorm(cnt-(cx,cy))

def pointdistance(point1,point2):
    """
    Distance from point1 to point2.

    :param point1: (x1,y1)
    :param point2: (x2,y2)
    :return: distance
    """
    x1,y1 = point1
    x2,y2 = point2
    return np.sqrt((x1-x2)**2+(y1-y2)**2)

def polygontest(src,cnt,mask = None):
    """
    Draw polygon test from contour in image.

    :param src: source binary image of int32
    :param cnt: contour
    :param mask: binary image
    :return: calculated polygontest with mask in src
    """
    if mask:
        for i,j in zip(*np.where(mask==1)):
            src.itemset((i,j),cv2.pointPolygonTest(cnt,(j,i),True))
        return src
    else:
        return _polygontest(src,cnt)

def polycenter(res):
    """
    Return centers from polygon test.

    :param res: polygontest
    :return: center, multiple centers
    """
    pts =  np.where(res == res.max())
    center_pts = zip(pts[1],pts[0])
    center = pts[1][len(pts[0])/2],pts[0][len(pts[0])/2]
    return center,center_pts

def getThreshCenter1(thresh):
    """
    Get center with distance Transform's method.

    :param thresh:
    :return:
    """
    dist_transform = cv2.distanceTransform(thresh,cv2.DIST_LABEL_PIXEL,5) # simulate inside points
    dist_transform[thresh==0] = -1 # simulate outside points
    center,center_pts = polycenter(dist_transform) # get centers
    return center

def getThreshCenter2(thresh):
    """
    Get center with moments' method.

    :param thresh:
    :return:
    """
    cnt = thresh_biggestCnt(thresh)
    M = cv2.moments(cnt) # find moments
    cx = int(M['m10']/M['m00'])
    cy = int(M['m01']/M['m00'])
    return cx,cy

def getThreshCenter3(thresh):
    """
    Get center with boxCenter method.

    :param thresh:
    :return:
    """
    y,x = np.where(thresh==1)
    return imcoors(zip(x,y),np.int32).boxCenter

def getThreshCenter4(thresh):
    """
    Get center with mean's method.

    :param thresh:
    :return:
    """
    y,x = np.where(thresh==1)
    return imcoors(zip(x,y),np.int32).mean

def CircleClosure(thresh,epsilon=0.5):
    """
    Rough reduction of bumps from a circle or ellipse.

    :param thresh: binary image
    :return: approximated contours
    """
    #GET DESIRED CENTER
    # simulate polygon test with distance transform
    dist_transform = cv2.distanceTransform(thresh,cv2.DIST_LABEL_PIXEL,5) # simulate inside points
    dist_transform[thresh==0] = -1 # simulate outside points
    center,center_pts = polycenter(dist_transform) # get centers
    centerVal = dist_transform[center[1],center[0]] # selected center value

    #DRAW CIRCLE
    overcircle = np.zeros_like(thresh,np.uint8) # circle canvas
    cv2.circle(overcircle,center,centerVal,1,-1) # draw circle
    overcircle[thresh==0]=0 # thresh mask
    cnt = thresh_biggestCnt(overcircle) # get contours of biggest object

    #DEFECTS
    hull = cv2.convexHull(cnt,returnPoints = False) # find hull
    defects = cv2.convexityDefects(cnt,hull) # find defects
    if twoMaxTest(defects,epsilon):
        #SEPARATING LINE
        start,end = extendedSeparatingLine(thresh.shape, cnt, defects) # find line from biggest defects
        newThresh = thresh.copy() # do not modify thresh
        cv2.line(newThresh,start,end,0,2) # draw separating line
        approxcnt = thresh_biggestCnt(newThresh) # get contours of biggest object
        return approxcnt # return approximated contours
    else:
        return thresh_biggestCnt(thresh) # return original contours, with no defects!

def graphpolygontest(test, win ="Polygon test", centralcol = (0, 100, 0), centercol=(100, 100, 0)):
    """
    Visualize polygon test with its centers.

    :param test: polygon test or (image, contours) to make polygon test
    :param win: window name
    :param centralcol: multiple centers' color
    :param centercol: center's color
    :return: plotim object

    Example::

        object.center_pts returns multiple centers
        object.center returns center most point
        object.sample returns polygontest
        object.plot() visualizes polygontest
    """
    if not isnumpy(test):
        src,cnt = test
        test = polygontest(src.copy().astype(np.int32),cnt,mask = None)

    graph = colorpolygontest(test)
    center,center_pts = polycenter(test)
    for pt in center_pts:
        cv2.circle(graph,pt,1,centralcol,-1)
    cv2.circle(graph,center,1,centercol,-1)
    plot = plotim(win,graph)
    plot.center_pts = center_pts
    plot.center = center
    plot.sample = test
    plot.showpixel = False
    return plot

def std_deviation(arr):
    """
    calculate the standard deviation of an array.

    :param arr: input array
    :return: standard deviation
    """
    arr = arr.flatten()
    mean = np.mean(arr)
    deviation = np.abs(arr - mean)
    variance = anorm2(deviation)/np.float(len(arr))
    standard_deviation= np.sqrt(variance)
    return standard_deviation

def plainness(ROI):
    """
    From ROI calculate plainness (measure of change of intensities over an area)

    :param ROI: region of interest
    :return: plainness value
    """
    # find normalized_histogram, and its cumulative distribution function
    hist, bins = np.histogram(ROI.flatten(),256,[0,256])
    #s_values, bin_idx, s_counts = np.unique(ROI.flatten(), return_inverse=True, return_counts=True)
    hist_norm = hist.astype("float").ravel()/hist.max()
    return std_deviation(hist_norm)