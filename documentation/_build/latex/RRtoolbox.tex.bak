% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}

\usepackage{babel}
\usepackage{times}
\usepackage[Sonny]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig. }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }



\title{RRtoolbox Documentation}
\date{October 24, 2016}
\release{1}
\author{David Toro}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\setcounter{tocdepth}{3}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{RRtoolbox package}
\label{RRtoolbox::doc}\label{RRtoolbox:welcome-to-rrtoolbox-s-documentation}\label{RRtoolbox:rrtoolbox-package}

\section{Subpackages}
\label{RRtoolbox:subpackages}

\subsection{RRtoolbox.lib package}
\label{RRtoolbox.lib:rrtoolbox-lib-package}\label{RRtoolbox.lib::doc}

\subsubsection{Subpackages}
\label{RRtoolbox.lib:subpackages}

\paragraph{RRtoolbox.lib.arrayops package}
\label{RRtoolbox.lib.arrayops:rrtoolbox-lib-arrayops-package}\label{RRtoolbox.lib.arrayops::doc}

\subparagraph{Submodules}
\label{RRtoolbox.lib.arrayops:submodules}

\subparagraph{RRtoolbox.lib.arrayops.basic module}
\label{RRtoolbox.lib.arrayops:rrtoolbox-lib-arrayops-basic-module}\label{RRtoolbox.lib.arrayops:module-RRtoolbox.lib.arrayops.basic}\index{RRtoolbox.lib.arrayops.basic (module)}
This module contains simple array operation methods
\index{angle() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.angle}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{angle}}{\emph{v1}, \emph{v2}, \emph{deg=False}}{}
Angle between two N dimmensional vectors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{v1}} -- vector 1.

\item {} 
\textbf{\texttt{v2}} -- vector 2.

\item {} 
\textbf{\texttt{deg}} -- if True angle is in Degrees, else radians.

\end{itemize}

\item[{Returns}] \leavevmode
angle in radians.

\end{description}\end{quote}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{angle\PYGZus{}between}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{1.5707963267948966}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{angle\PYGZus{}between}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{0.0}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{angle\PYGZus{}between}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{3.141592653589793}
\end{Verbatim}

\begin{notice}{note}{Note:}
obtained from \href{http://stackoverflow.com/a/13849249/5288758}{http://stackoverflow.com/a/13849249/5288758}
and tested in \href{http://onlinemschool.com/math/assistance/vector/angl/}{http://onlinemschool.com/math/assistance/vector/angl/}
\end{notice}

\end{fulllineitems}

\index{angle2D() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.angle2D}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{angle2D}}{\emph{v1}, \emph{v2}, \emph{deg=False}, \emph{absolute=None}}{}
Angle between two 2 dimensional vectors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{v1}} -- vector 1.

\item {} 
\textbf{\texttt{v2}} -- vector 2.

\item {} 
\textbf{\texttt{deg}} -- if True angle is in Degrees, else radians.

\item {} 
\textbf{\texttt{absolute}} -- if None returns the angle (0 yo 180(pi)) between v1 and v2.
if True returns the absolute angle (0 to 360(2pi)) from v1 as axis to v2.
if False returns the angle (0 to 180 or 0 to -180) from v1 as axis to v2,
where v2 angle relative to v1 is positive or negative if counter-clock or clock wise.

\end{itemize}

\item[{Returns}] \leavevmode
angle in radians.

\end{description}\end{quote}

\begin{notice}{note}{Note:}
implemented according to \href{http://math.stackexchange.com/a/747992}{http://math.stackexchange.com/a/747992}
and tested in \href{http://onlinemschool.com/math/assistance/vector/angl/}{http://onlinemschool.com/math/assistance/vector/angl/}
\end{notice}

\end{fulllineitems}

\index{angleXY() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.angleXY}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{angleXY}}{\emph{coorX}, \emph{coorY}, \emph{angle}}{}
Rotate coordinate.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{coorX}} -- x coordinate.

\item {} 
\textbf{\texttt{coorY}} -- y coordinate.

\item {} 
\textbf{\texttt{angle}} -- radian angle.

\end{itemize}

\item[{Returns}] \leavevmode
rotated x,y

\end{description}\end{quote}

\end{fulllineitems}

\index{anorm() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.anorm}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{anorm}}{\emph{a}}{}
norm in array.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{a}} -- 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{anorm2() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.anorm2}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{anorm2}}{\emph{a}}{}
Summation of squares (helper function for {\hyperref[RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.anorm]{\emph{\code{anorm()}}}})
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{a}} -- 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{axesIntercept() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.axesIntercept}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{axesIntercept}}{\emph{coorSM}, \emph{maxS}, \emph{maxM}}{}
Intercept static axis (S) and mobile axis (M) with a coordinate connecting
both axes from minS to minM.
\begin{quote}
\begin{quote}

S1                     S2
\end{quote}

S0 {\color{red}\bfseries{}\textbar{}\textless{}---------------------\textbar{}}-----------\textgreater{} maxS
\end{quote}
\begin{description}
\item[{coorSM \textless{}---------\textbar{}                      \textbar{}}] \leavevmode\begin{quote}

M1                     M2
\end{quote}

M0 \textless{}---------{\color{red}\bfseries{}\textbar{}---------------------\textgreater{}\textbar{}} maxM

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{coorSM}} -- coordinate of vector from S=0 to M=0.

\item {} 
\textbf{\texttt{maxS}} -- value representing end of estatic axis.

\item {} 
\textbf{\texttt{maxM}} -- value representing end of mobile axis.

\end{itemize}

\item[{Returns}] \leavevmode
S1,S2,M1,M2.

\end{description}\end{quote}

\end{fulllineitems}

\index{boxPads() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.boxPads}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{boxPads}}{\emph{bx}, \emph{points}}{}
Get box pads to fit all.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{bx}} -- box coordinates or previous boxPads {[}left\_top, right\_bottom{]}

\item {} 
\textbf{\texttt{points}} -- array of points

\end{itemize}

\item[{Returns}] \leavevmode
{[}(left,top),(right,bottom){]} where bx and points fit.

\end{description}\end{quote}

\end{fulllineitems}

\index{centerM() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.centerM}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{centerM}}{\emph{coor}, \emph{maxM}}{}
Center vector coor in M axis.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{coor}} -- coordinate of vector from S=0 to M center

\item {} 
\textbf{\texttt{maxM}} -- value representing end of mobile axis

\end{itemize}

\item[{Returns}] \leavevmode
M centered coordinate

\end{description}\end{quote}

\end{fulllineitems}

\index{centerS() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.centerS}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{centerS}}{\emph{coor}, \emph{maxS}}{}
Center vector coor in S axis.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{coor}} -- coordinate of vector from S center to M=0

\item {} 
\textbf{\texttt{maxS}} -- value representing end of estatic axis

\end{itemize}

\item[{Returns}] \leavevmode
S centered coordinate

\end{description}\end{quote}

\end{fulllineitems}

\index{centerSM() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.centerSM}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{centerSM}}{\emph{coorSM}, \emph{maxS}, \emph{maxM}}{}
Center vector coorSM in both S and M axes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{coorSM}} -- coordinate of vector from S to M centers.

\item {} 
\textbf{\texttt{maxS}} -- value representing end of estatic axis.

\item {} 
\textbf{\texttt{maxM}} -- value representing end of mobile axis.

\end{itemize}

\item[{Returns}] \leavevmode
SM centered coordinate.

\end{description}\end{quote}

\end{fulllineitems}

\index{contours2mask() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.contours2mask}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{contours2mask}}{\emph{contours}, \emph{shape=None}, \emph{astype=\textless{}type `bool'\textgreater{}}}{}
Creates an array with filled polygons formed by contours.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{contours}} -- list of contour or points forming objects

\item {} 
\textbf{\texttt{shape}} -- (None) shape of array. If None it creates an array fitted to contours.

\item {} 
\textbf{\texttt{astype}} -- (``bool'') numpy type

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{contoursArea() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.contoursArea}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{contoursArea}}{\emph{contours}}{}
Accumulates areas from list of contours.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{contours}} -- list of contours or binary array.

\item[{Returns}] \leavevmode
area.

\end{description}\end{quote}

\end{fulllineitems}

\index{convertXY() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.convertXY}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{convertXY}}{\emph{x}, \emph{y}, \emph{backshape}, \emph{foreshape}, \emph{flag=0}, \emph{quartile=0}, \emph{angle=None}}{}
Convert absolute XY 0,0 coordinates to new system WZ.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{x}} -- x coordinate.

\item {} 
\textbf{\texttt{y}} -- y coordinate.

\item {} 
\textbf{\texttt{backshape}} -- shape of background image.

\end{itemize}

\end{description}\end{quote}

:param foreshape:shape of foreground image.
:param flag: flag for position (default=0).
\begin{itemize}
\item {} 
flag==0 : foreground to left up.

\item {} 
flag==1 : foreground to left down.

\item {} 
flag==2 : foreground to right up.

\item {} 
flag==3 : foreground to right down.

\item {} 
flag==4 : foreground at center of background.

\item {} 
flag==5 : XY 0,0 is at center of background.

\item {} 
flag==6 : XY 0,0 is at center of foreground.

\item {} 
flag==7 : XY 0,0 is at right down of foreground.

\end{itemize}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{quartile}} -- place Mobile image at quartile 1,2,3,4.
if left quartile=0 image won't be moved.

\item {} 
\textbf{\texttt{angle}} -- angle in radians (defalut=None). if None it does not apply.

\end{itemize}

\item[{Returns}] \leavevmode
W,Z

\end{description}\end{quote}

\end{fulllineitems}

\index{convexityRatio() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.convexityRatio}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{convexityRatio}}{\emph{cnt}, \emph{hull=None}}{}
Ratio to test if contours are irregular
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{cnt}} -- contour

\end{description}\end{quote}

:param hull:(None) convex hull
:return: ratio

\end{fulllineitems}

\index{entroyTest() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.entroyTest}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{entroyTest}}{\emph{arr}}{}
Entropy test of intensity arrays. (Helper function for \code{entropy()})
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{arr}} -- array MxN of dim 2.

\item[{Returns}] \leavevmode
entropy.

\end{description}\end{quote}

\end{fulllineitems}

\index{find\_near() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.find_near}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{find\_near}}{\emph{m}, \emph{thresh=None}, \emph{side=None}}{}
helper function for findminima and findmaxima
:param m: minima or maxima points
:param thresh: guess or seed point
:param side: left or right
:return: value

\end{fulllineitems}

\index{findmaxima() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.findmaxima}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{findmaxima}}{\emph{hist}, \emph{thresh=None}, \emph{side=None}}{}
Get nearest peak value to a thresh point from a histogram.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{hist}} -- histogram

\item {} 
\textbf{\texttt{thresh}} -- initial seed

\item {} 
\textbf{\texttt{side}} -- find valley from left or right of thresh

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{findminima() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.findminima}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{findminima}}{\emph{hist}, \emph{thresh=None}, \emph{side=None}}{}
Get nearest valley value to a thresh point from a histogram.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{hist}} -- histogram

\item {} 
\textbf{\texttt{thresh}} -- initial seed

\item {} 
\textbf{\texttt{side}} -- find valley from left or right of thresh

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{getOtsuThresh() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.getOtsuThresh}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{getOtsuThresh}}{\emph{hist}}{}
From histogram calculate Otsu threshold value.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{hist}} -- histogram

\item[{Returns}] \leavevmode
otsu threshold value

\end{description}\end{quote}

\end{fulllineitems}

\index{getTransformedCorners() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.getTransformedCorners}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{getTransformedCorners}}{\emph{shape}, \emph{H}}{}
from shape gets transformed corners of array.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{shape}} -- H,W array shape

\item {} 
\textbf{\texttt{H}} -- transformation matrix

\end{itemize}

\item[{Returns}] \leavevmode
upper\_left, upper\_right, lower\_right, lower\_lef transformed corners.

\end{description}\end{quote}

\end{fulllineitems}

\index{getTransparency() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.getTransparency}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{getTransparency}}{\emph{array}}{}
Convert foreground to background.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{array}} -- image array.

\item[{Returns}] \leavevmode
alfa (int or array)

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_x\_space() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.get_x_space}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{get\_x\_space}}{\emph{funcs}, \emph{step=10}, \emph{xleft=-300}, \emph{xright=300}}{}
get X axis space by brute force. This can be used to find the x points
where the points in the y axis of any number of functions become stable.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{funcs}} -- list of functions

\item {} 
\textbf{\texttt{step}} -- \begin{enumerate}
\setcounter{enumi}{9}
\item {} 
step to close guess to maximum

\end{enumerate}


\item {} 
\textbf{\texttt{xleft}} -- maximum left limit

\item {} 
\textbf{\texttt{xright}} -- maximum right limit

\end{itemize}

\item[{Returns}] \leavevmode
linspace

\end{description}\end{quote}

\end{fulllineitems}

\index{getdataVH() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.getdataVH}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{getdataVH}}{\emph{array}, \emph{ypad=0}, \emph{xpad=0}, \emph{bgrcolor=None}, \emph{alfa=None}}{}
Get data from array according to padding (Helper function for {\hyperref[RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.padVH]{\emph{\code{padVH()}}}}).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{array}} -- list of arrays to get data

\item {} 
\textbf{\texttt{ypad}} -- how much to pad in y axis

\item {} 
\textbf{\texttt{xpad}} -- how much to pad in x axis

\end{itemize}

\item[{Returns}] \leavevmode
matrix\_shapes, grid\_div, row\_grid, row\_gridpad, globalgrid

\end{description}\end{quote}

\end{fulllineitems}

\index{histogram() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.histogram}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{histogram}}{\emph{img}}{}
Get image histogram.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{img}} -- gray or image with any bands

\item[{Returns}] \leavevmode
histogram of every band

\end{description}\end{quote}

\end{fulllineitems}

\index{im2imFormat() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.im2imFormat}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{im2imFormat}}{\emph{src}, \emph{dst}}{}
Tries to convert source image to destine image format.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{src}} -- source image.

\item {} 
\textbf{\texttt{dst}} -- destine image.

\end{itemize}

\item[{Returns}] \leavevmode
reshaped source image.

\end{description}\end{quote}

\end{fulllineitems}

\index{im2shapeFormat() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.im2shapeFormat}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{im2shapeFormat}}{\emph{im}, \emph{shape}}{}
Tries to convert image to intuited format from shape.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{im}} -- image.

\item {} 
\textbf{\texttt{shape}} -- 
shape to get format.

shapes:
* (None, None): converts to gray
* (None, None, 2): converts to GR555
* (None, None, 3): converts to BGR
* (None, None, 4): converts to BGRA


\end{itemize}

\item[{Returns}] \leavevmode
reshaped image.

\end{description}\end{quote}

\end{fulllineitems}

\index{instability\_bf() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.instability_bf}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{instability\_bf}}{\emph{funcs}, \emph{step=10}, \emph{maximum=300}, \emph{guess=0}, \emph{tolerance=0.01}}{}
Find the instability of function approaching value by brute force,
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{funcs}} -- list of functions

\item {} 
\textbf{\texttt{step}} -- \begin{enumerate}
\setcounter{enumi}{9}
\item {} 
step to close guess to maximum

\end{enumerate}


\item {} 
\textbf{\texttt{maximum}} -- \begin{enumerate}
\setcounter{enumi}{299}
\item {} 
maximum value, if guess surpass this value then calculations are stopped.

\end{enumerate}


\item {} 
\textbf{\texttt{guess}} -- \begin{enumerate}
\setcounter{enumi}{-1}
\item {} 
initial guess

\end{enumerate}


\item {} 
\textbf{\texttt{tolerance}} -- (0.01) tolerance with last step to check instability.

\end{itemize}

\item[{Returns}] \leavevmode
(state, updated guess). state is True if successful, else False.

\end{description}\end{quote}

\end{fulllineitems}

\index{invertM() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.invertM}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{invertM}}{\emph{coorSM}, \emph{maxM}}{}
Invert M axis.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{coorSM}} -- coordinate of vector for M inverted axes.

\item {} 
\textbf{\texttt{maxS}} -- value representing end of estatic axis.

\item {} 
\textbf{\texttt{maxM}} -- value representing end of mobile axis.

\end{itemize}

\item[{Returns}] \leavevmode
SM coordinate on S axis and inverted M axis.

\end{description}\end{quote}

\end{fulllineitems}

\index{invertSM() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.invertSM}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{invertSM}}{\emph{coorSM}, \emph{maxS}, \emph{maxM}}{}
Invert S and M axes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{coorSM}} -- coordinate of vector for SM inverted axes.

\item {} 
\textbf{\texttt{maxS}} -- value representing end of estatic axis.

\item {} 
\textbf{\texttt{maxM}} -- value representing end of mobile axis.

\end{itemize}

\item[{Returns}] \leavevmode
SM coordinate on inverted SM axes.

\end{description}\end{quote}

\end{fulllineitems}

\index{isnumpy() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.isnumpy}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{isnumpy}}{\emph{arr}}{}
Test whether an object is a numpy array.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{arr}} -- 

\item[{Returns}] \leavevmode
True if numpy array, else false.

\end{description}\end{quote}

\end{fulllineitems}

\index{makeVis() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.makeVis}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{makeVis}}{\emph{globalgrid}, \emph{bgrcolor=None}}{}
Make visualization (Helper function for {\hyperref[RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.padVH]{\emph{\code{padVH()}}}})
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{globalgrid}} -- shape

\item {} 
\textbf{\texttt{bgrcolor}} -- color of visualization

\end{itemize}

\item[{Returns}] \leavevmode
array of shape globalgrid

\end{description}\end{quote}

\end{fulllineitems}

\index{matrixIntercept() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.matrixIntercept}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{matrixIntercept}}{\emph{x}, \emph{y}, \emph{staticm}, \emph{*mobilem}}{}
Intercepts planes x and y of a static matrix (staticm) with N mobile matrices (mobilem)
translated from the origin to x,y coordinates.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{x}} -- x coordinate.

\item {} 
\textbf{\texttt{y}} -- y coordinate.

\item {} 
\textbf{\texttt{staticm}} -- static matrix.

\item {} 
\textbf{\texttt{mobilem}} -- mobile matrices.

\end{itemize}

\item[{Returns}] \leavevmode
ROI of intercepted matrices {[}staticm,*mobilem{]}.

\end{description}\end{quote}

\end{fulllineitems}

\index{multiple\_superpose() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.multiple_superpose}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{multiple\_superpose}}{\emph{base}, \emph{fore}, \emph{H}, \emph{foremask=None}}{}
Superpose multiple foreground images to a single base image.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{base}} -- backgraound, base or dipest level image (level -1)

\item {} 
\textbf{\texttt{fore}} -- foreground image list (in order of level i = 0, ... , N)

\item {} 
\textbf{\texttt{H}} -- transformation matrix of fore in level i to overlay in base

\item {} 
\textbf{\texttt{foremask}} -- foreground alfa mask in level i

\end{itemize}

\item[{Returns}] \leavevmode
generator of each overlay

\end{description}\end{quote}

\end{fulllineitems}

\index{noisy() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.noisy}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{noisy}}{\emph{arr}, \emph{mode}}{}
Add noise to arrays
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{arr}} -- Input ndarray data (it will be converted to float).

\item {} 
\textbf{\texttt{mode}} -- 
noise method:
\begin{itemize}
\item {} 
`gauss' - Gaussian-distributed additive noise.

\item {} 
`poisson' - Poisson-distributed noise generated from the data.

\item {} 
`s\&p' - Replaces random pixels with 0 or 1.

\item {} \begin{description}
\item[{`speckle' - Multiplicative noise using out = arr + n*arr,where}] \leavevmode
n is uniform noise with specified mean \& variance.

\end{description}

\end{itemize}


\end{itemize}

\end{description}\end{quote}

:return noisy arr

\end{fulllineitems}

\index{normalize() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.normalize}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{normalize}}{\emph{arr}}{}
Normalize array to ensure range {[}0,1{]}

\end{fulllineitems}

\index{normalize2() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.normalize2}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{normalize2}}{\emph{arr}}{}
Normalize with factor of absolute maximum value.

\end{fulllineitems}

\index{normalizeCustom() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.normalizeCustom}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{normalizeCustom}}{\emph{arr}, \emph{by=\textless{}function amax\textgreater{}}, \emph{axis=None}}{}
Normalize array with custom operations.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{arr}} -- array (it does not correct negative values, use preferable NxM).

\item {} 
\textbf{\texttt{by}} -- np,max, np.sum or any function that gets an array to obtain factor.

\item {} 
\textbf{\texttt{axis}} -- if None it normalizes in all axes else in the selected axis.

\end{itemize}

\item[{Returns}] \leavevmode
normalized to with factor.

\end{description}\end{quote}

\end{fulllineitems}

\index{overlay() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.overlay}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{overlay}}{\emph{back}, \emph{fore}, \emph{alpha=None}, \emph{alfainverted=False}, \emph{under=False}, \emph{flag=0}}{}
Try to Overlay any dimension array.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{back}} -- BGRA background image.

\item {} 
\textbf{\texttt{fore}} -- BGRA foreground image.

\item {} 
\textbf{\texttt{alpha}} -- transparency channel.

\item {} 
\textbf{\texttt{alfainverted}} -- if True inverts alpha transparency.

\item {} 
\textbf{\texttt{under}} -- if True, place back as fore and fore as back.

\item {} 
\textbf{\texttt{flag}} -- 
(experimental)
\begin{enumerate}
\setcounter{enumi}{-1}
\item {} \begin{description}
\item[{Normally replace inverted transparency of alpha in back (N);}] \leavevmode
superpose alpha in back (V).

\end{description}

\item {} \begin{description}
\item[{Bloat and replace inverted transparency of alpha in back;}] \leavevmode
superpose bgr in back (V).

\end{description}

\item {} 
Superpose inverted transparent COLOR of alpha in back.

\item {} 
Superpose inverted transparent COLOR of alpha in back.

\item {} \begin{description}
\item[{Superpose transparent of alpha in back;}] \leavevmode
superpose transparent COLOR of alpha in back.

\end{description}

\item {} \begin{description}
\item[{Superpose transparent of alpha in back;}] \leavevmode
superpose transparent COLOR of alpha in back.

\end{description}

\end{enumerate}


\end{itemize}

\item[{Returns}] \leavevmode
overlayed array

\end{description}\end{quote}


\strong{See also:}


{\hyperref[RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.overlay2]{\emph{\code{overlay2()}}}}



\end{fulllineitems}

\index{overlay2() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.overlay2}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{overlay2}}{\emph{back}, \emph{fore}}{}
Overlay foreground to x,y coordinates in background image.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{back}} -- background image (numpy array dim 3).

\item {} 
\textbf{\texttt{fore}} -- foreground image (numpy array dim 4). the fourth
dimension is used for transparency.

\end{itemize}

\item[{Returns}] \leavevmode
back (with overlay).

\end{description}\end{quote}

\#Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{cv2}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{time}
\PYG{n}{a}\PYG{o}{=} \PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{back} \PYG{o}{=} \PYG{n}{cv2}\PYG{o}{.}\PYG{n}{imread}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{t1.jpg}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{temp} \PYG{o}{=} \PYG{n}{back}\PYG{o}{.}\PYG{n}{shape}
\PYG{n}{bgr} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{temp}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{temp}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{uint8}\PYG{p}{)}
\PYG{n}{points} \PYG{o}{=} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{86}\PYG{p}{,} \PYG{l+m+mi}{162}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1219}\PYG{p}{,} \PYG{l+m+mi}{1112}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{2219}\PYG{p}{,} \PYG{l+m+mi}{2112}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1277}\PYG{p}{,}\PYG{l+m+mi}{3000}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+m+mi}{86}\PYG{p}{,} \PYG{l+m+mi}{162}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{col\PYGZus{}in} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{255}\PYG{p}{)}
\PYG{n}{thickness} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{points}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{pt1} \PYG{o}{=} \PYG{p}{(}\PYG{n}{points}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{points}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{pt2} \PYG{o}{=} \PYG{p}{(}\PYG{n}{points}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{points}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{cv2}\PYG{o}{.}\PYG{n}{line}\PYG{p}{(}\PYG{n}{bgr}\PYG{p}{,} \PYG{n}{pt1}\PYG{p}{,} \PYG{n}{pt2}\PYG{p}{,} \PYG{n}{col\PYGZus{}in}\PYG{p}{,} \PYG{n}{thickness}\PYG{p}{)}

\PYG{n}{overlay}\PYG{p}{(}\PYG{n}{back}\PYG{p}{,}\PYG{n}{bgr}\PYG{p}{)}

\PYG{n}{win} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{overlay}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{cv2}\PYG{o}{.}\PYG{n}{namedWindow}\PYG{p}{(}\PYG{n}{win}\PYG{p}{,}\PYG{n}{cv2}\PYG{o}{.}\PYG{n}{WINDOW\PYGZus{}NORMAL}\PYG{p}{)}
\PYG{n}{cv2}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{win}\PYG{p}{,} \PYG{n}{back}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{a}
\PYG{n}{cv2}\PYG{o}{.}\PYG{n}{waitKey}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{cv2}\PYG{o}{.}\PYG{n}{destroyAllWindows}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}


\strong{See also:}


{\hyperref[RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.overlay]{\emph{\code{overlay()}}}}



\end{fulllineitems}

\index{overlayXY() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.overlayXY}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{overlayXY}}{\emph{x}, \emph{y}, \emph{back}, \emph{fore}, \emph{alfa=None}, \emph{alfainverted=False}, \emph{under=False}, \emph{flag=0}}{}
Overlay foreground image to x,y coordinates in background image.
This function support images of different sizes with formats: BGR background
and BGRA foreground of Opencv or numpy images.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{x}} -- x position in background.

\item {} 
\textbf{\texttt{y}} -- y position in background.

\item {} 
\textbf{\texttt{back}} -- background image (numpy array dim 3).

\item {} 
\textbf{\texttt{fore}} -- foreground image (numpy array dim 4). the fourth
dimension is used for transparency.

\end{itemize}

\item[{Returns}] \leavevmode
back (with overlay)

\end{description}\end{quote}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{cv2}
\PYG{n}{back} \PYG{o}{=} \PYG{n}{cv2}\PYG{o}{.}\PYG{n}{imread}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{t1.jpg}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{bgr} \PYG{o}{=} \PYG{n}{cv2}\PYG{o}{.}\PYG{n}{imread}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{mustache.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{o}{=}\PYG{n}{convertXY}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{back}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{,}\PYG{n}{bgr}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{,}\PYG{n}{flag}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{overlayXY}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{back}\PYG{p}{,}\PYG{n}{bgr}\PYG{p}{)}
\PYG{n}{win} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{overlay}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{cv2}\PYG{o}{.}\PYG{n}{namedWindow}\PYG{p}{(}\PYG{n}{win}\PYG{p}{,}\PYG{n}{cv2}\PYG{o}{.}\PYG{n}{WINDOW\PYGZus{}NORMAL}\PYG{p}{)}
\PYG{n}{cv2}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{win}\PYG{p}{,} \PYG{n}{back}\PYG{p}{)}
\PYG{n}{cv2}\PYG{o}{.}\PYG{n}{waitKey}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{cv2}\PYG{o}{.}\PYG{n}{destroyAllWindows}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{overlaypng() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.overlaypng}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{overlaypng}}{\emph{back}, \emph{fore}, \emph{alpha=None}, \emph{alfainverted=False}, \emph{under=False}, \emph{flag=0}}{}
Overlay only BGRA.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{back}} -- BGRA background image.

\item {} 
\textbf{\texttt{fore}} -- BGRA foreground image.

\item {} 
\textbf{\texttt{alpha}} -- transparency channel.

\item {} 
\textbf{\texttt{alfainverted}} -- if True inverts alpha transparency.

\item {} 
\textbf{\texttt{under}} -- if True, place back as fore and fore as back.

\item {} 
\textbf{\texttt{flag}} -- 
(experimental)
\begin{enumerate}
\setcounter{enumi}{-1}
\item {} \begin{description}
\item[{Normally replace inverted transparency of alpha in back (N);}] \leavevmode
superpose alpha in back (V).

\end{description}

\item {} \begin{description}
\item[{Bloat and replace inverted transparency of alpha in back;}] \leavevmode
superpose bgr in back (V).

\end{description}

\item {} 
Superpose inverted transparent COLOR of alpha in back.

\item {} 
Superpose inverted transparent COLOR of alpha in back.

\item {} \begin{description}
\item[{Superpose transparent of alpha in back;}] \leavevmode
superpose transparent COLOR of alpha in back.

\end{description}

\item {} \begin{description}
\item[{Superpose transparent of alpha in back;}] \leavevmode
superpose transparent COLOR of alpha in back.

\end{description}

\end{enumerate}


\end{itemize}

\item[{Returns}] \leavevmode
overlayed array

\end{description}\end{quote}


\strong{See also:}


{\hyperref[RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.overlay]{\emph{\code{overlay()}}}}, {\hyperref[RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.overlay2]{\emph{\code{overlay2()}}}}



\end{fulllineitems}

\index{padVH() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.padVH}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{padVH}}{\emph{imgs}, \emph{ypad=0}, \emph{xpad=0}, \emph{bgrcolor=None}, \emph{alfa=None}}{}
Pad Vertically and Horizontally image or group of images into an array.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{imgs}} -- image to pad or list of horizontal images (i.e. piled
up horizontally as {[}V1,..,VN{]} where each can be a list
of vertical piling VN = {[}H1,..,HM{]}. It can be successive
like horizontals, verticals, horizontals, etc.

\item {} 
\textbf{\texttt{ypad}} -- padding in axis y

\item {} 
\textbf{\texttt{xpad}} -- padding in axis x

\item {} 
\textbf{\texttt{bgrcolor}} -- color of spaces

\item {} 
\textbf{\texttt{alfa}} -- transparency of imgs over background of bgrcolor color.

\end{itemize}

\item[{Returns}] \leavevmode
visualization of paded and piled images in imgs.

\end{description}\end{quote}

\end{fulllineitems}

\index{pad\_to\_fit\_H() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.pad_to_fit_H}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{pad\_to\_fit\_H}}{\emph{shape1}, \emph{shape2}, \emph{H}}{}
get boxPads to fit transformed shape1 in shape2.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{shape1}} -- shape of array 1

\item {} 
\textbf{\texttt{shape2}} -- shape of array 2

\item {} 
\textbf{\texttt{H}} -- transformation matrix to use in shape1

\end{itemize}

\item[{Returns}] \leavevmode
{[}(left,top),(right,bottom){]}

\end{description}\end{quote}

\end{fulllineitems}

\index{points2mask() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.points2mask}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{points2mask}}{\emph{pts}, \emph{shape=None}, \emph{astype=\textless{}type `bool'\textgreater{}}}{}
Creates an array with the filled polygon formed by points.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{pts}} -- points.

\item {} 
\textbf{\texttt{shape}} -- (None) shape of array. If None it creates an array fitted to points.

\item {} 
\textbf{\texttt{astype}} -- (``bool'') numpy type

\end{itemize}

\item[{Returns}] \leavevmode
array.

\end{description}\end{quote}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{pts} \PYG{o}{=} \PYG{n}{random\PYGZus{}points}\PYG{p}{(}\PYG{p}{[}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{img} \PYG{o}{=} \PYG{n}{points2mask}\PYG{p}{(}\PYG{n}{pts}\PYG{p}{)}
\PYG{n}{Plotim}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{filled}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{img}\PYG{p}{)}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{points\_generator() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.points_generator}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{points\_generator}}{\emph{shape=(10}, \emph{10)}, \emph{nopoints=None}, \emph{convex=False}, \emph{erratic=False}, \emph{complete=False}}{}
generate points.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{shape}} -- enclosed frame (width, height)

\item {} 
\textbf{\texttt{nopoints}} -- number of points

\item {} 
\textbf{\texttt{convex}} -- if True make points convex,
else points follow a circular pattern.

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{polygonArea() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.polygonArea}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{polygonArea}}{\emph{pts}}{}
Area of points calculating polygon Area.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{pts}} -- points.

\item[{Returns}] \leavevmode
area value.

\end{description}\end{quote}
\begin{description}
\item[{..note::}] \leavevmode\begin{itemize}
\item {} 
If polygon is incomplete (last is not first point) it completes the array.

\item {} 
If the polygon crosses over itself the algorithm will fail.

\item {} 
Based on \href{http://www.mathopenref.com/coordpolygonarea.html}{http://www.mathopenref.com/coordpolygonarea.html}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{polygonArea\_calcule() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.polygonArea_calcule}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{polygonArea\_calcule}}{\emph{pts}}{}
Area of points calculating polygon Area.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{pts}} -- points.

\item[{Returns}] \leavevmode
area value.

\end{description}\end{quote}
\begin{description}
\item[{..note::}] \leavevmode\begin{itemize}
\item {} 
If polygon is incomplete (last is not first point) it completes the array.

\item {} 
If the polygon crosses over itself the algorithm will fail.

\item {} 
Based on \href{http://www.mathopenref.com/coordpolygonarea.html}{http://www.mathopenref.com/coordpolygonarea.html}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{polygonArea\_contour() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.polygonArea_contour}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{polygonArea\_contour}}{\emph{pts}}{}
Area of points using contours.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{pts}} -- points.

\item[{Returns}] \leavevmode
area value.

\end{description}\end{quote}

..note:: if polygon is incomplete (last is not first point) it completes the array.

\end{fulllineitems}

\index{polygonArea\_fill() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.polygonArea_fill}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{polygonArea\_fill}}{\emph{pts}}{}
Area of points using filled polygon and pixel count.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{pts}} -- points.

\item[{Returns}] \leavevmode
area value.

\end{description}\end{quote}

..note:: if polygon is incomplete (last is not first point) it completes the array.

\end{fulllineitems}

\index{process\_as\_blocks() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.process_as_blocks}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{process\_as\_blocks}}{\emph{arr}, \emph{func}, \emph{block\_shape=(3}, \emph{3)}, \emph{mask=None}, \emph{asWindows=False}}{}
process with function over an array using blocks (using re-striding).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{arr}} -- array to process

\item {} 
\textbf{\texttt{func}} -- function to feed blocks

\item {} 
\textbf{\texttt{block\_shape}} -- (3,3) shape of blocks

\item {} 
\textbf{\texttt{mask}} -- (None) mask to process arr

\item {} 
\textbf{\texttt{asWindows}} -- (False) if True all blocks overlap each other to give
a result for each position of arr, if False the results are
given in blocks equivalent for each processed blocks of arr (faster).

\end{itemize}

\item[{Returns}] \leavevmode
processed array.

\end{description}\end{quote}

\end{fulllineitems}

\index{quadrant() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.quadrant}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{quadrant}}{\emph{coorX}, \emph{coorY}, \emph{maxX}, \emph{maxY}, \emph{quadrant=0}}{}
Moves a point to a quadrant
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{coorX}} -- point in x coordinate

\item {} 
\textbf{\texttt{coorY}} -- point in y coordinate

\item {} 
\textbf{\texttt{maxX}} -- max value in x axis

\item {} 
\textbf{\texttt{maxY}} -- max value in y axis

\item {} 
\textbf{\texttt{quadrant}} -- Cartesian quadrant, if 0 or False it leaves coorX and coorY unprocessed.

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{random\_points() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.random_points}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{random\_points}}{\emph{axes\_range=((-50}, \emph{50)}, \emph{)}, \emph{nopoints=4}, \emph{complete=False}}{}
Get random points.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{axes\_range}} -- {[}x\_points\_range, y\_points\_range{]} where points\_range is (min,max) range in axis.

\item {} 
\textbf{\texttt{nopoints}} -- number of points.

\item {} 
\textbf{\texttt{complete}} -- last point is the first point (adds an additional point i.e. nopoints+1).

\end{itemize}

\item[{Returns}] \leavevmode
numpy array.

\end{description}\end{quote}

\end{fulllineitems}

\index{recursiveMap() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.recursiveMap}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{recursiveMap}}{\emph{function}, \emph{sequence}}{}
Iterate recursively over a structure using a function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{function}} -- function to apply

\item {} 
\textbf{\texttt{sequence}} -- iterator

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{relativeQuadrants() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.relativeQuadrants}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{relativeQuadrants}}{\emph{points}}{}
Get quadrants of relative vectors obtained from points.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{points}} -- array of points.

\item[{Returns}] \leavevmode
quadrants.

\end{description}\end{quote}

\end{fulllineitems}

\index{relativeVectors() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.relativeVectors}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{relativeVectors}}{\emph{pts}, \emph{all=True}}{}
Form vectors from points.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{pts}} -- array of points {[}p0, ... ,(x,y){]}.

\item {} 
\textbf{\texttt{all}} -- (True) if True adds last vector from last and first point.

\end{itemize}

\item[{Returns}] \leavevmode
array of vectors {[}V0, ... , (V{[}n{]} = x{[}n+1{]}-x{[}n{]},y{[}n+1{]}-y{[}n{]}){]}.

\end{description}\end{quote}

\end{fulllineitems}

\index{rescale() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.rescale}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{rescale}}{\emph{arr}, \emph{max=1}, \emph{min=0}}{}
Rescales array values to range {[}min,max{]}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{arr}} -- array.

\item {} 
\textbf{\texttt{max}} -- maximum value in range.

\item {} 
\textbf{\texttt{min}} -- minimum value in range.

\end{itemize}

\item[{Returns}] \leavevmode
rescaled array.

\end{description}\end{quote}

\end{fulllineitems}

\index{separePointsByAxis() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.separePointsByAxis}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{separePointsByAxis}}{\emph{pts}, \emph{ptaxis=(1}, \emph{0)}, \emph{origin=(0}, \emph{0)}}{}
Separate scattered points with respect to axis (splitting line).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{pts}} -- points to separate.

\item {} 
\textbf{\texttt{ptaxis}} -- point to form axis from origin

\item {} 
\textbf{\texttt{origin}} -- origin

\end{itemize}

\item[{Returns}] \leavevmode
left, right points from axis.

\end{description}\end{quote}

\end{fulllineitems}

\index{splitPoints() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.splitPoints}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{splitPoints}}{\emph{pts}, \emph{aslist=None}}{}
from points get x,y columns
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{pts}} -- array of points

\item {} 
\textbf{\texttt{aslist}} -- True to return lists instead of arrays

\end{itemize}

\item[{Returns}] \leavevmode
x, y columns

\end{description}\end{quote}

\end{fulllineitems}

\index{standarizePoints() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.standarizePoints}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{standarizePoints}}{\emph{pts}, \emph{aslist=False}}{}
converts points to a standard form
:param pts: list or array of points
:param aslist: True to return list instead of array
:return: standard points

\end{fulllineitems}

\index{superpose() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.superpose}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{superpose}}{\emph{back}, \emph{fore}, \emph{H}, \emph{foreMask=None}, \emph{grow=True}}{}
Superpose foreground image to background image.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{back}} -- background image

\item {} 
\textbf{\texttt{fore}} -- foreground image

\item {} 
\textbf{\texttt{H}} -- transformation matrix of fore to overlay in back

\item {} 
\textbf{\texttt{foreMask}} -- (None) foreground alpha mask, None or function.
foreMask values are from 1 for solid to 0 for transparency.
If a function is provided the new back,fore parameters are
provided to produce the foreMask. If None is provided
as foreMask then it is equivalent to a foreMask with all
values to 1 where fore is True.

\item {} 
\textbf{\texttt{grow}} -- If True, im can be bigger than back and is calculated
according to how fore is superposed in back; if False
im is of the same shape as back.

\end{itemize}

\item[{Returns}] \leavevmode
im, H\_back, H\_fore

\end{description}\end{quote}

\end{fulllineitems}

\index{transformPoint() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.transformPoint}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{transformPoint}}{\emph{p}, \emph{H}}{}
Transform individual x,y point with Transformation Matrix.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{p}} -- x,y point

\item {} 
\textbf{\texttt{H}} -- transformation matrix

\end{itemize}

\item[{Returns}] \leavevmode
transformed x,y point

\end{description}\end{quote}

\end{fulllineitems}

\index{transformPoints() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.transformPoints}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{transformPoints}}{\emph{p}, \emph{H}}{}
Transform x,y points in array with Transformation Matrix.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{p}} -- array of points

\item {} 
\textbf{\texttt{H}} -- transformation matrix

\end{itemize}

\item[{Returns}] \leavevmode
transformed array of x,y point

\end{description}\end{quote}

\end{fulllineitems}

\index{unit\_vector() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.unit_vector}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{unit\_vector}}{\emph{vector}}{}
Returns the unit vector of the vector.

\end{fulllineitems}

\index{vectorsAngles() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.vectorsAngles}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{vectorsAngles}}{\emph{pts}, \emph{ptaxis=(1}, \emph{0)}, \emph{origin=(0}, \emph{0)}, \emph{dtype=None}, \emph{deg=False}, \emph{absolute=None}}{}
Angle of formed vectors in Cartesian plane with respect to formed axis vector.
\begin{description}
\item[{i.e. angle between vector ``Vn'' (formed by point ``Pn'' and the ``origin'')}] \leavevmode\begin{quote}

and vector ``Vaxis'' formed by ``ptaxis'' and the ``origin''.
\end{quote}

where pts-origin = (P0-origin ... Pn-origin) = V0 ... Vn

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{pts}} -- points to form vectors from origin

\item {} 
\textbf{\texttt{ptaxis}} -- point to form axis from origin

\item {} 
\textbf{\texttt{origin}} -- origin

\item {} 
\textbf{\texttt{dtype}} -- return array of type supported by numpy.

\item {} 
\textbf{\texttt{deg}} -- if True angle is in Degrees, else radians.

\item {} 
\textbf{\texttt{absolute}} -- if None returns angles (0 yo 180(pi)) between  pts-origin (V0 .. Vn) and Vaxis.
if True returns any Vn absolute angle (0 to 360(2pi)) from Vaxis as axis to Vn.
if False returns any Vn angle (0 to 180 or 0 to -180) from Vaxis as axis to Vn,
where any Vn angle is positive or negative if counter-clock or clock wise from Vaxis.

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{vectorsQuadrants() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.vectorsQuadrants}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{vectorsQuadrants}}{\emph{vecs}}{}
Get quadrants of vectors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{vecs}} -- array of vectors.

\item[{Returns}] \leavevmode
quadrants.

\end{description}\end{quote}

\end{fulllineitems}

\index{vertexesAngles() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.vertexesAngles}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{vertexesAngles}}{\emph{pts}, \emph{dtype=None}, \emph{deg=False}}{}
Relative angle of vectors formed by vertexes (where vectors cross).
\begin{description}
\item[{i.e. angle between vectors ``v01'' formed by points ``p0-p1'' and ``v12''}] \leavevmode
formed by points ``p1-p2'' where ``p1'' is seen as a vertex (where vectors cross).

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{pts}} -- points seen as vertexes (vectors are recreated from point to point).

\item {} 
\textbf{\texttt{dtype}} -- return array of type supported by numpy.

\item {} 
\textbf{\texttt{deg}} -- if True angle is in Degrees, else radians.

\end{itemize}

\item[{Returns}] \leavevmode
angles.

\end{description}\end{quote}

\end{fulllineitems}

\index{view\_as\_blocks() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.view_as_blocks}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{view\_as\_blocks}}{\emph{arr\_in}, \emph{block\_shape=(3}, \emph{3)}}{}
Provide a 2D block\_shape view to 2D array. No error checking made.
Therefore meaningful (as implemented) only for blocks strictly
compatible with the shape of arr\_in.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{arr\_in}} -- 

\item {} 
\textbf{\texttt{block\_shape}} -- 

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{view\_as\_windows() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.view_as_windows}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{view\_as\_windows}}{\emph{arr\_in}, \emph{window\_shape}, \emph{step=1}}{}
Provide a 2D block\_shape rolling view to 2D array. No error checking made.
Therefore meaningful (as implemented) only for blocks strictly
compatible with the shape of arr\_in.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{arr\_in}} -- 

\item {} 
\textbf{\texttt{window\_shape}} -- 

\item {} 
\textbf{\texttt{step}} -- 

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{RRtoolbox.lib.arrayops.convert module}
\label{RRtoolbox.lib.arrayops:module-RRtoolbox.lib.arrayops.convert}\label{RRtoolbox.lib.arrayops:rrtoolbox-lib-arrayops-convert-module}\index{RRtoolbox.lib.arrayops.convert (module)}
This module unlike common and basic array operations classifies just the from-to-conversions methods
\index{SimKeyPoint (class in RRtoolbox.lib.arrayops.convert)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.convert.SimKeyPoint}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.arrayops.convert.}\bfcode{SimKeyPoint}}{\emph{*args}}{}
Simulates opencv keypoint (it allows manipulation, conversion and serialization of keypoints).

\begin{notice}{note}{Note:}
Used for conversions and data persistence.
\end{notice}

\end{fulllineitems}

\index{apply2kp\_pairs() (in module RRtoolbox.lib.arrayops.convert)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.convert.apply2kp_pairs}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.convert.}\bfcode{apply2kp\_pairs}}{\emph{kp\_pairs}, \emph{kp1\_rel}, \emph{kp2\_rel}, \emph{func=None}}{}
Apply to kp\_pairs.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{kp\_pairs}} -- list of (kp1,kp2) pairs

\item {} 
\textbf{\texttt{kp1\_rel}} -- x,y relation or function to apply to kp1

\item {} 
\textbf{\texttt{kp2\_rel}} -- x,y relation or function to apply to kp2

\item {} 
\textbf{\texttt{func}} -- function to build new copy of keypoint

\end{itemize}

\item[{Returns}] \leavevmode
transformed kp\_pairs

\end{description}\end{quote}

\end{fulllineitems}

\index{cnt2pts() (in module RRtoolbox.lib.arrayops.convert)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.convert.cnt2pts}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.convert.}\bfcode{cnt2pts}}{\emph{contours}}{}
Convert contours to points. (cnt2pts)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{contours}} -- array of contours (cnt) ({[}{[}x,y{]}{]} only for openCV)

\item[{Returns}] \leavevmode


\end{description}\end{quote}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{contours} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} contours}
\PYG{n}{points} \PYG{o}{=} \PYG{n}{contour2points}\PYG{p}{(}\PYG{n}{contours}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{points} \PYG{c+c1}{\PYGZsh{} np.array([[0, 0], [1, 0]])}
\end{Verbatim}

\end{fulllineitems}

\index{contour2points() (in module RRtoolbox.lib.arrayops.convert)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.convert.contour2points}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.convert.}\bfcode{contour2points}}{\emph{contours}}{}
Convert contours to points. (cnt2pts)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{contours}} -- array of contours (cnt) ({[}{[}x,y{]}{]} only for openCV)

\item[{Returns}] \leavevmode


\end{description}\end{quote}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{contours} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} contours}
\PYG{n}{points} \PYG{o}{=} \PYG{n}{contour2points}\PYG{p}{(}\PYG{n}{contours}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{points} \PYG{c+c1}{\PYGZsh{} np.array([[0, 0], [1, 0]])}
\end{Verbatim}

\end{fulllineitems}

\index{conv3H4H() (in module RRtoolbox.lib.arrayops.convert)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.convert.conv3H4H}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.convert.}\bfcode{conv3H4H}}{\emph{M}}{}
Convert a 3D transformation matrix (TM) to 4D TM.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{M}} -- Matrix

\item[{Returns}] \leavevmode
4D Matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{dict2keyPoint() (in module RRtoolbox.lib.arrayops.convert)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.convert.dict2keyPoint}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.convert.}\bfcode{dict2keyPoint}}{\emph{d}, \emph{func=\textless{}built-in function KeyPoint\textgreater{}}}{}
KeyPoint({[}x, y, \_size{[}, \_angle{[}, \_response{[}, \_octave{[}, \_class\_id{]}{]}{]}{]}{]}) -\textgreater{} \textless{}KeyPoint object\textgreater{}

\end{fulllineitems}

\index{getSOpointRelation() (in module RRtoolbox.lib.arrayops.convert)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.convert.getSOpointRelation}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.convert.}\bfcode{getSOpointRelation}}{\emph{source\_shape}, \emph{destine\_shape}, \emph{asMatrix=False}}{}
Return parameters to change scaled point to original point.
\begin{quote}

\# destine\_domain = relation*source\_domain
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{source\_shape}} -- image shape for source domain

\item {} 
\textbf{\texttt{destine\_shape}} -- image shape for destine domain

\item {} 
\textbf{\texttt{asMatrix}} -- if true returns a Transformation Matrix H

\end{itemize}

\item[{Returns}] \leavevmode
x, y coordinate relations or H if asMatrix is True

\end{description}\end{quote}

\begin{notice}{note}{Note:}
Used to get relations to convert scaled points to original points of an Image.
\end{notice}

\end{fulllineitems}

\index{invertH() (in module RRtoolbox.lib.arrayops.convert)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.convert.invertH}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.convert.}\bfcode{invertH}}{\emph{H}}{}
Invert Transformation Matrix.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{H}} -- 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{keyPoint2tuple() (in module RRtoolbox.lib.arrayops.convert)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.convert.keyPoint2tuple}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.convert.}\bfcode{keyPoint2tuple}}{\emph{keypoint}}{}
obj.angle, obj.class\_id, obj.octave, obj.pt, obj.response, obj.size

\end{fulllineitems}

\index{points2contour() (in module RRtoolbox.lib.arrayops.convert)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.convert.points2contour}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.convert.}\bfcode{points2contour}}{\emph{points}}{}
Convert points to contours. (pts2cnt)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{points}} -- array of points ({[}x,y{]} for openCV, {[}y,x{]} for numpy)

\item[{Returns}] \leavevmode


\end{description}\end{quote}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{points} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} points}
\PYG{n}{contours} \PYG{o}{=} \PYG{n}{points2contour}\PYG{p}{(}\PYG{n}{points}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{contours} \PYG{c+c1}{\PYGZsh{} np.array([[[0, 0]], [[1, 0]]])}
\end{Verbatim}

\end{fulllineitems}

\index{points2vectos() (in module RRtoolbox.lib.arrayops.convert)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.convert.points2vectos}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.convert.}\bfcode{points2vectos}}{\emph{pts}, \emph{origin=None}}{}
Convert points to vectors with respect to origin.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{pts}} -- array of points.

\item {} 
\textbf{\texttt{origin}} -- point of origin.

\end{itemize}

\item[{Returns}] \leavevmode
vectors.

\end{description}\end{quote}

\end{fulllineitems}

\index{pts2cnt() (in module RRtoolbox.lib.arrayops.convert)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.convert.pts2cnt}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.convert.}\bfcode{pts2cnt}}{\emph{points}}{}
Convert points to contours. (pts2cnt)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{points}} -- array of points ({[}x,y{]} for openCV, {[}y,x{]} for numpy)

\item[{Returns}] \leavevmode


\end{description}\end{quote}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{points} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} points}
\PYG{n}{contours} \PYG{o}{=} \PYG{n}{points2contour}\PYG{p}{(}\PYG{n}{points}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{contours} \PYG{c+c1}{\PYGZsh{} np.array([[[0, 0]], [[1, 0]]])}
\end{Verbatim}

\end{fulllineitems}

\index{sh2oh() (in module RRtoolbox.lib.arrayops.convert)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.convert.sh2oh}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.convert.}\bfcode{sh2oh}}{\emph{sH}, \emph{osrc\_sh}, \emph{sscr\_sh}, \emph{odst\_sh}, \emph{sdst\_sh}}{}
Convert scaled transformation matrix (sH) to original (oH).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{sH}} -- scaled transformation matrix

\item {} 
\textbf{\texttt{osrc\_sh}} -- original source's shape

\item {} 
\textbf{\texttt{sscr\_sh}} -- scaled source's shape

\item {} 
\textbf{\texttt{odst\_sh}} -- original destine's shape

\item {} 
\textbf{\texttt{sdst\_sh}} -- scaled destine's shape

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{spairs2opairs() (in module RRtoolbox.lib.arrayops.convert)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.convert.spairs2opairs}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.convert.}\bfcode{spairs2opairs}}{\emph{kp\_pairs}, \emph{osrc\_sh}, \emph{sscr\_sh}, \emph{odst\_sh}, \emph{sdst\_sh}, \emph{func=None}}{}
Convert scaled kp\_pairs to original kp\_pairs.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{kp\_pairs}} -- list of kp\_pairs

\item {} 
\textbf{\texttt{osrc\_sh}} -- original source's shape

\item {} 
\textbf{\texttt{sscr\_sh}} -- scaled source's shape

\item {} 
\textbf{\texttt{odst\_sh}} -- original destine's shape

\item {} 
\textbf{\texttt{sdst\_sh}} -- scaled destine's shape

\item {} 
\textbf{\texttt{func}} -- function to build new copy of keypoint

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{spoint2opointfunc() (in module RRtoolbox.lib.arrayops.convert)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.convert.spoint2opointfunc}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.convert.}\bfcode{spoint2opointfunc}}{\emph{source\_shape}, \emph{destine\_shape}}{}
Return function with parameters to change scaled point to original point.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{source\_shape}} -- 

\item {} 
\textbf{\texttt{destine\_shape}} -- shape of

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{forefunc} \PYG{o}{=} \PYG{n}{scaled2realfunc}\PYG{p}{(}\PYG{n}{imgf}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{,}\PYG{n}{bgr}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}
\PYG{n}{backfunc} \PYG{o}{=} \PYG{n}{scaled2realfunc}\PYG{p}{(}\PYG{n}{imgb}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{,}\PYG{n}{back}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}
\PYG{n}{p1fore} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{forefunc}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{p1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{p2back} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{backfunc}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{p2}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{toTupple() (in module RRtoolbox.lib.arrayops.convert)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.convert.toTupple}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.convert.}\bfcode{toTupple}}{\emph{obj}}{}
Converts recursively to tuple
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{obj}} -- numpy array, list structure, iterators, etc.

\item[{Returns}] \leavevmode
tuple representation obj.

\end{description}\end{quote}

\end{fulllineitems}

\index{translateQuadrants() (in module RRtoolbox.lib.arrayops.convert)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.convert.translateQuadrants}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.convert.}\bfcode{translateQuadrants}}{\emph{quadrants}, \emph{quadrantmap=\{(0}, \emph{1): `up'}, \emph{(-1}, \emph{1): `left-up'}, \emph{(0}, \emph{0): `origin'}, \emph{(-1}, \emph{0): `left'}, \emph{(-1}, \emph{-1): `left-down'}, \emph{(0}, \emph{-1): `down'}, \emph{(1}, \emph{0): `right'}, \emph{(1}, \emph{-1): `right-down'}, \emph{(1}, \emph{1): `right-up'\}}}{}
Convert quadrants into human readable data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{quadrants}} -- array of quadrants.

\item {} 
\textbf{\texttt{quadrantmap}} -- 
dictionary map to translate quadrants. it is of the form:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZob{}(0,0):\PYGZdq{}origin\PYGZdq{},(1,0):\PYGZdq{}right\PYGZdq{},(1,1):\PYGZdq{}top\PYGZhy{}right\PYGZdq{},(0,1):\PYGZdq{}top\PYGZdq{},(\PYGZhy{}1,1):\PYGZdq{}top\PYGZhy{}left\PYGZdq{},
\end{Verbatim}
\begin{quote}

(-1,0):''left'',(-1,-1):''bottom-left'',(0,-1):''bottom'',(1,-1):''bottom-right''\}
\end{quote}


\end{itemize}

\item[{Returns}] \leavevmode
list of translated quadrants.

\end{description}\end{quote}

\end{fulllineitems}

\index{tuple2keyPoint() (in module RRtoolbox.lib.arrayops.convert)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.convert.tuple2keyPoint}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.convert.}\bfcode{tuple2keyPoint}}{\emph{points}, \emph{func=\textless{}built-in function KeyPoint\textgreater{}}}{}
KeyPoint({[}x, y, \_size{[}, \_angle{[}, \_response{[}, \_octave{[}, \_class\_id{]}{]}{]}{]}{]}) -\textgreater{} \textless{}KeyPoint object\textgreater{}

\end{fulllineitems}

\index{vectos2points() (in module RRtoolbox.lib.arrayops.convert)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.convert.vectos2points}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.convert.}\bfcode{vectos2points}}{\emph{vecs}, \emph{origin=None}}{}
Convert points to vectors with respect to origin.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{vecs}} -- array of vectors.

\item {} 
\textbf{\texttt{origin}} -- point of origin.

\end{itemize}

\item[{Returns}] \leavevmode
points.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{RRtoolbox.lib.arrayops.filters module}
\label{RRtoolbox.lib.arrayops:rrtoolbox-lib-arrayops-filters-module}\label{RRtoolbox.lib.arrayops:module-RRtoolbox.lib.arrayops.filters}\index{RRtoolbox.lib.arrayops.filters (module)}
This module contains custom 1D adn 2D-array filters and pre-processing (as in filtering phase) methods
\index{Bandpass (class in RRtoolbox.lib.arrayops.filters)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.Bandpass}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.arrayops.filters.}\bfcode{Bandpass}}{\emph{alpha}, \emph{beta1}, \emph{beta2}}{}
Bases: {\hyperref[RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.FilterBase]{\emph{\code{RRtoolbox.lib.arrayops.filters.FilterBase}}}}

Bandpass filter (recommended to use float types)

\end{fulllineitems}

\index{Bandstop (class in RRtoolbox.lib.arrayops.filters)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.Bandstop}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.arrayops.filters.}\bfcode{Bandstop}}{\emph{alpha}, \emph{beta1}, \emph{beta2}}{}
Bases: {\hyperref[RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.FilterBase]{\emph{\code{RRtoolbox.lib.arrayops.filters.FilterBase}}}}

Bandstop filter (recommended to use float types)

\end{fulllineitems}

\index{BilateraParameter (class in RRtoolbox.lib.arrayops.filters)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.BilateraParameter}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.arrayops.filters.}\bfcode{BilateraParameter}}{\emph{scale}, \emph{shift=33}, \emph{name=None}, \emph{alpha=100}, \emph{beta1=-400}, \emph{beta2=200}}{}
Bases: {\hyperref[RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.Bandstop]{\emph{\code{RRtoolbox.lib.arrayops.filters.Bandstop}}}}

bilateral parameter

\end{fulllineitems}

\index{BilateralParameters (class in RRtoolbox.lib.arrayops.filters)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.BilateralParameters}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.arrayops.filters.}\bfcode{BilateralParameters}}{\emph{d=None}, \emph{sigmaColor=None}, \emph{sigmaSpace=None}}{}
Bases: \code{object}

create instance to calculate bilateral
parameters from image shape.
\begin{description}
\item[{d -\textgreater{} inf then:}] \leavevmode\begin{itemize}
\item {} 
computation is slower

\item {} 
filtering is better to eliminate noise

\item {} 
images look more cartoon-like

\end{itemize}

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{d}} -- distance

\item {} 
\textbf{\texttt{sigmaColor}} -- sigma in color

\item {} 
\textbf{\texttt{sigmaSpace}} -- sigma in space

\end{itemize}

\end{description}\end{quote}
\index{d (RRtoolbox.lib.arrayops.filters.BilateralParameters attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.BilateralParameters.d}\pysigline{\bfcode{d}\strong{ = \textless{}RRtoolbox.lib.arrayops.filters.BilateraParameter object\textgreater{}}}
\end{fulllineitems}

\index{filters (RRtoolbox.lib.arrayops.filters.BilateralParameters attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.BilateralParameters.filters}\pysigline{\bfcode{filters}}
list of filters

\end{fulllineitems}

\index{sigmaColor (RRtoolbox.lib.arrayops.filters.BilateralParameters attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.BilateralParameters.sigmaColor}\pysigline{\bfcode{sigmaColor}\strong{ = \textless{}RRtoolbox.lib.arrayops.filters.BilateraParameter object\textgreater{}}}
\end{fulllineitems}

\index{sigmaSpace (RRtoolbox.lib.arrayops.filters.BilateralParameters attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.BilateralParameters.sigmaSpace}\pysigline{\bfcode{sigmaSpace}\strong{ = \textless{}RRtoolbox.lib.arrayops.filters.BilateraParameter object\textgreater{}}}
\end{fulllineitems}


\end{fulllineitems}

\index{FilterBase (class in RRtoolbox.lib.arrayops.filters)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.FilterBase}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.arrayops.filters.}\bfcode{FilterBase}}{\emph{alpha=None}, \emph{beta1=None}, \emph{beta2=None}}{}
Bases: \code{object}

base filter to create custom filters
\index{alpha (RRtoolbox.lib.arrayops.filters.FilterBase attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.FilterBase.alpha}\pysigline{\bfcode{alpha}}
\end{fulllineitems}

\index{beta1 (RRtoolbox.lib.arrayops.filters.FilterBase attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.FilterBase.beta1}\pysigline{\bfcode{beta1}}
\end{fulllineitems}

\index{beta2 (RRtoolbox.lib.arrayops.filters.FilterBase attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.FilterBase.beta2}\pysigline{\bfcode{beta2}}
\end{fulllineitems}


\end{fulllineitems}

\index{Highpass (class in RRtoolbox.lib.arrayops.filters)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.Highpass}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.arrayops.filters.}\bfcode{Highpass}}{\emph{alpha}, \emph{beta1}}{}
Bases: {\hyperref[RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.FilterBase]{\emph{\code{RRtoolbox.lib.arrayops.filters.FilterBase}}}}

Highpass filter (recommended to use float types)

\end{fulllineitems}

\index{InvertedBandpass (class in RRtoolbox.lib.arrayops.filters)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.InvertedBandpass}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.arrayops.filters.}\bfcode{InvertedBandpass}}{\emph{alpha}, \emph{beta1}, \emph{beta2}}{}
Bases: {\hyperref[RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.Bandpass]{\emph{\code{RRtoolbox.lib.arrayops.filters.Bandpass}}}}

inverted Bandpass filter (recommended to use float types)

\end{fulllineitems}

\index{InvertedBandstop (class in RRtoolbox.lib.arrayops.filters)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.InvertedBandstop}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.arrayops.filters.}\bfcode{InvertedBandstop}}{\emph{alpha}, \emph{beta1}, \emph{beta2}}{}
Bases: {\hyperref[RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.Bandstop]{\emph{\code{RRtoolbox.lib.arrayops.filters.Bandstop}}}}

inverted Bandstop filter (recommended to use float types)

\end{fulllineitems}

\index{Lowpass (class in RRtoolbox.lib.arrayops.filters)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.Lowpass}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.arrayops.filters.}\bfcode{Lowpass}}{\emph{alpha}, \emph{beta1}}{}
Bases: {\hyperref[RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.FilterBase]{\emph{\code{RRtoolbox.lib.arrayops.filters.FilterBase}}}}

Lowpass filter (recommended to use float types)

\end{fulllineitems}

\index{bilateralFilter() (in module RRtoolbox.lib.arrayops.filters)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.bilateralFilter}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.filters.}\bfcode{bilateralFilter}}{\emph{im}, \emph{d}, \emph{sigmaColor}, \emph{sigmaSpace}}{}
Apply bilateral Filter.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{im}} -- 

\item {} 
\textbf{\texttt{d}} -- 

\item {} 
\textbf{\texttt{sigmaColor}} -- 

\item {} 
\textbf{\texttt{sigmaSpace}} -- 

\end{itemize}

\item[{Returns}] \leavevmode
filtered image

\end{description}\end{quote}

\end{fulllineitems}

\index{filterFactory() (in module RRtoolbox.lib.arrayops.filters)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.filterFactory}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.filters.}\bfcode{filterFactory}}{\emph{alpha}, \emph{beta1}, \emph{beta2=None}}{}
Make filter.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{alpha}} -- steepness of filter

\item {} 
\textbf{\texttt{beta1}} -- first shift from origin

\item {} 
\textbf{\texttt{beta2}} -- 
second shift from origin:

alpha must be != 0
if beta2 = None:
\begin{quote}

if alpha \textgreater{} 0: high-pass filter, if alpha \textless{} 0: low-pass filter
\end{quote}
\begin{description}
\item[{else:}] \leavevmode\begin{description}
\item[{if beta2 \textgreater{} beta1:}] \leavevmode
if alpha \textgreater{} 0: band-pass filter, if alpha \textless{} 0: band-stop filter

\item[{else:}] \leavevmode
if alpha \textgreater{} 0: inverted-band-pass filter, if alpha \textless{} 0: inverted-band-stop filter

\end{description}

\end{description}


\end{itemize}

\item[{Returns}] \leavevmode
filter funtion with intup levels

\end{description}\end{quote}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{alpha}\PYG{p}{,}\PYG{n}{beta1}\PYG{p}{,}\PYG{n}{beta2} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{100}
\PYG{n}{myfilter} \PYG{o}{=} \PYG{n+nb}{filter}\PYG{p}{(}\PYG{n}{alpha}\PYG{p}{,}\PYG{n}{beta1}\PYG{p}{,}\PYG{n}{beta2}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{myfilter}\PYG{p}{,}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{myfilter}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{myfilter}\PYG{o}{.}\PYG{n}{alpha}\PYG{p}{,}\PYG{n}{myfilter}\PYG{o}{.}\PYG{n}{beta1}\PYG{p}{,}\PYG{n}{myfilter}\PYG{o}{.}\PYG{n}{beta2}
\end{Verbatim}

\end{fulllineitems}

\index{getBilateralParameters() (in module RRtoolbox.lib.arrayops.filters)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.getBilateralParameters}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.filters.}\bfcode{getBilateralParameters}}{\emph{shape=None}, \emph{mode=None}}{}
Calculate from shape bilateral parameters.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{shape}} -- image shape. if None it returns the instace to use with shapes.

\item {} 
\textbf{\texttt{mode}} -- ``mild'', ``heavy'' or ``normal'' to process noise

\end{itemize}

\item[{Returns}] \leavevmode
instance or parameters

\end{description}\end{quote}

\end{fulllineitems}

\index{normsigmoid() (in module RRtoolbox.lib.arrayops.filters)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.normsigmoid}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.filters.}\bfcode{normsigmoid}}{\emph{x}, \emph{alpha}, \emph{beta}}{}
Apply normalized sigmoid filter.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{x}} -- data to apply filter

\item {} 
\textbf{\texttt{alpha}} -- if alpha \textgreater{} 0: pass high filter, if alpha \textless{} 0: pass low filter, alpha must be != 0

\item {} 
\textbf{\texttt{beta}} -- shift from origin

\end{itemize}

\item[{Returns}] \leavevmode
filtered values normalized to range {[}-1 if x\textless{}0, 1 if x\textgreater{}=0{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{sigmoid() (in module RRtoolbox.lib.arrayops.filters)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.sigmoid}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.filters.}\bfcode{sigmoid}}{\emph{x}, \emph{alpha}, \emph{beta}, \emph{max=255}, \emph{min=0}}{}
Apply sigmoid filter.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{x}} -- data to apply filter

\item {} 
\textbf{\texttt{alpha}} -- if alpha \textgreater{} 0: pass high filter, if alpha \textless{} 0: pass low filter, alpha must be != 0

\item {} 
\textbf{\texttt{beta}} -- shift from origin

\item {} 
\textbf{\texttt{max}} -- maximum output value

\item {} 
\textbf{\texttt{min}} -- minimum output value

\end{itemize}

\item[{Returns}] \leavevmode
filtered values ranging as {[}min,max{]}

\end{description}\end{quote}

\begin{notice}{note}{Note:}
Based from \href{http://www.itk.org/Doxygen/html/classitk\_1\_1SigmoidImageFilter.html}{http://www.itk.org/Doxygen/html/classitk\_1\_1SigmoidImageFilter.html}
\end{notice}

\end{fulllineitems}

\index{smooth() (in module RRtoolbox.lib.arrayops.filters)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.smooth}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.filters.}\bfcode{smooth}}{\emph{x}, \emph{window\_len=11}, \emph{window='hanning'}, \emph{correct=False}}{}
Smooth the data using a window with requested size.

This method is based on the convolution of a scaled window with the signal.
The signal is prepared by introducing reflected copies of the signal
(with the window size) in both ends so that transient parts are minimized
in the beginning and end part of the output signal.
\begin{description}
\item[{input:}] \leavevmode
x: the input signal
window\_len: the dimension of the smoothing window; should be an odd integer
window: the type of window from `flat', `hanning', `hamming', `bartlett', `blackman'
\begin{quote}

flat window will produce a moving average smoothing.
\end{quote}

\item[{output:}] \leavevmode
the smoothed signal

\end{description}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{t}\PYG{o}{=}\PYG{n}{linspace}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mf}{0.1}\PYG{p}{)}
\PYG{n}{x}\PYG{o}{=}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{o}{+}\PYG{n}{randn}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{0.1}
\PYG{n}{y}\PYG{o}{=}\PYG{n}{smooth}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\end{Verbatim}


\strong{See also:}


numpy.hanning, numpy.hamming, numpy.bartlett, numpy.blackman, numpy.convolve, scipy.signal.lfilter



\begin{notice}{note}{Note:}
length(output) != length(input), to correct this: return y{[}(window\_len/2-1):-(window\_len/2){]} instead of just y.
\end{notice}

\end{fulllineitems}



\subparagraph{RRtoolbox.lib.arrayops.mask module}
\label{RRtoolbox.lib.arrayops:module-RRtoolbox.lib.arrayops.mask}\label{RRtoolbox.lib.arrayops:rrtoolbox-lib-arrayops-mask-module}\index{RRtoolbox.lib.arrayops.mask (module)}
This module contains all basic masking and pre-processing (as in segmenting phase) methods
\index{background() (in module RRtoolbox.lib.arrayops.mask)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.mask.background}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.mask.}\bfcode{background}}{\emph{gray}, \emph{mask=None}, \emph{iterations=3}}{}
get the background mask of a gray image. (this it the inverted of {\hyperref[RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.mask.foreground]{\emph{\code{foreground()}}}})
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{gray}} -- gray image

\item {} 
\textbf{\texttt{mask}} -- (None) input mask to process gray

\item {} 
\textbf{\texttt{iterations}} -- (3) number of iterations to detect background
with otsu threshold.

\end{itemize}

\item[{Returns}] \leavevmode
output mask

\end{description}\end{quote}

\end{fulllineitems}

\index{biggestCnt() (in module RRtoolbox.lib.arrayops.mask)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.mask.biggestCnt}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.mask.}\bfcode{biggestCnt}}{\emph{contours}}{}
Filters contours to get biggest contour.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{contours}} -- 

\item[{Returns}] \leavevmode
cnt

\end{description}\end{quote}

\end{fulllineitems}

\index{biggestCntData() (in module RRtoolbox.lib.arrayops.mask)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.mask.biggestCntData}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.mask.}\bfcode{biggestCntData}}{\emph{contours}}{}
Gets index and area of biggest contour.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{contours}} -- 

\item[{Returns}] \leavevmode
index, area

\end{description}\end{quote}

\end{fulllineitems}

\index{brightness() (in module RRtoolbox.lib.arrayops.mask)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.mask.brightness}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.mask.}\bfcode{brightness}}{\emph{img}}{}
get brightness from an image
:param img: BGR or gray image
:return:

\end{fulllineitems}

\index{cnt\_hist() (in module RRtoolbox.lib.arrayops.mask)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.mask.cnt_hist}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.mask.}\bfcode{cnt\_hist}}{\emph{gray}}{}
Mask of a ellipse enclosing retina using histogram threshold.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{gray}} -- gray image

\item {} 
\textbf{\texttt{invert}} -- invert mask

\end{itemize}

\item[{Returns}] \leavevmode
mask

\end{description}\end{quote}

\end{fulllineitems}

\index{foreground() (in module RRtoolbox.lib.arrayops.mask)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.mask.foreground}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.mask.}\bfcode{foreground}}{\emph{gray}, \emph{mask=None}, \emph{iterations=3}}{}
get the foreground mask of a gray image. (this it the inverted of {\hyperref[RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.mask.background]{\emph{\code{background()}}}})
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{gray}} -- gray image

\item {} 
\textbf{\texttt{mask}} -- (None) input mask to process gray

\item {} 
\textbf{\texttt{iterations}} -- (3) number of iterations to detect foreground
with otsu threshold.

\end{itemize}

\item[{Returns}] \leavevmode
output mask

\end{description}\end{quote}

\end{fulllineitems}

\index{gethull() (in module RRtoolbox.lib.arrayops.mask)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.mask.gethull}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.mask.}\bfcode{gethull}}{\emph{contours}}{}
Get convex hull.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{contours}} -- contours or mask array

\item[{Returns}] \leavevmode
cnt

\end{description}\end{quote}

\end{fulllineitems}

\index{hist\_cdf() (in module RRtoolbox.lib.arrayops.mask)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.mask.hist_cdf}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.mask.}\bfcode{hist\_cdf}}{\emph{img}, \emph{window\_len=0}, \emph{window='hanning'}}{}
Get image histogram and the normalized cumulative distribution function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{img}} -- imaeg

\item {} 
\textbf{\texttt{window\_len}} -- 

\item {} 
\textbf{\texttt{window}} -- 

\end{itemize}

\item[{Returns}] \leavevmode
histogram (int), normalized cdf (float)

\end{description}\end{quote}

\end{fulllineitems}

\index{mask\_watershed() (in module RRtoolbox.lib.arrayops.mask)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.mask.mask_watershed}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.mask.}\bfcode{mask\_watershed}}{\emph{BGR}, \emph{GRAY=None}}{}
Get retinal mask with watershed method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{BGR}} -- 

\item {} 
\textbf{\texttt{GRAY}} -- 

\end{itemize}

\item[{Returns}] \leavevmode
mask

\end{description}\end{quote}

\end{fulllineitems}

\index{multiple\_otsu() (in module RRtoolbox.lib.arrayops.mask)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.mask.multiple_otsu}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.mask.}\bfcode{multiple\_otsu}}{\emph{gray}, \emph{mask=None}, \emph{flag=0L}, \emph{iterations=1}}{}
get the mask of a gray image applying Otsu threshold.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{gray}} -- gray image

\item {} 
\textbf{\texttt{mask}} -- (None) input mask to process gray

\item {} 
\textbf{\texttt{iterations}} -- \begin{enumerate}
\item {} 
number of iterations to detect Otsu threshold.

\end{enumerate}


\end{itemize}

\item[{Returns}] \leavevmode
thresh, mask

\end{description}\end{quote}

\end{fulllineitems}

\index{thresh\_biggestCnt() (in module RRtoolbox.lib.arrayops.mask)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.mask.thresh_biggestCnt}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.mask.}\bfcode{thresh\_biggestCnt}}{\emph{thresh}}{}
From threshold obtain biggest contour.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{thresh}} -- binary image

\item[{Returns}] \leavevmode
cnt

\end{description}\end{quote}

\end{fulllineitems}

\index{thresh\_hist() (in module RRtoolbox.lib.arrayops.mask)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.mask.thresh_hist}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.mask.}\bfcode{thresh\_hist}}{\emph{gray}}{}
Get best possible thresh to threshold object from the gray image.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{gray}} -- gray image.

\item[{Returns}] \leavevmode
thresh value.

\end{description}\end{quote}

\end{fulllineitems}

\index{threshold\_opening() (in module RRtoolbox.lib.arrayops.mask)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.mask.threshold_opening}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.mask.}\bfcode{threshold\_opening}}{\emph{src}, \emph{thresh}, \emph{maxval}, \emph{type}}{}
Eliminate small objects from threshold.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{src}} -- 

\item {} 
\textbf{\texttt{thresh}} -- 

\item {} 
\textbf{\texttt{maxval}} -- 

\item {} 
\textbf{\texttt{type}} -- 

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{Module contents}
\label{RRtoolbox.lib.arrayops:module-RRtoolbox.lib.arrayops}\label{RRtoolbox.lib.arrayops:module-contents}\index{RRtoolbox.lib.arrayops (module)}

\subsubsection{Submodules}
\label{RRtoolbox.lib:submodules}

\subsubsection{RRtoolbox.lib.cache module}
\label{RRtoolbox.lib:rrtoolbox-lib-cache-module}\label{RRtoolbox.lib:module-RRtoolbox.lib.cache}\index{RRtoolbox.lib.cache (module)}\begin{quote}\begin{description}
\item[{platform}] \leavevmode
Unix, Windows

\item[{synopsis}] \leavevmode
Serialize and Memoize.

\end{description}\end{quote}

Contains memoizing, caching, serializing and memory-mapping methods so as to let the package
save its state (persistence) and to let a method ``remember'' what it processed in a session (with cache) or
between sessions (memoization and serializization) of the same input contend once processed. It also wraps mmapping
functions to let objects ``live'' in the disk (slower but almost unlimited) rather than in memory (faster but limited).

\emph{@cache} is used as replacement of \emph{@property} to compute a class method once.
It is computed only one time after which an attribute of the same name is generated in its place.

\emph{@cachedProperty} is used as replacement of \emph{@property} to compute
a class method depending on changes in its watched variables.

\emph{@memoize} used as a general memoizer decorator for functions
where metadata is generated to disk for persistence.

Made by Davtoh, powered by joblib.
Dependent project: \href{https://github.com/joblib/joblib}{https://github.com/joblib/joblib}
\index{Cache (class in RRtoolbox.lib.cache)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.Cache}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.cache.}\bfcode{Cache}}{\emph{func}}{}
Bases: \code{object}

Descriptor (non-data) for building an attribute on-demand at first use.
@cache decorator is used for class methods without inputs (only self reference to the object)
and it caches on first compute. ex:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{x}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nd}{@cache}
    \PYG{k}{def} \PYG{n+nf}{method\PYGZus{}x}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data}
\end{Verbatim}

\begin{notice}{note}{Note:}
Cached data can be deleted in the decorated object to recalculate its value.
\end{notice}

\end{fulllineitems}

\index{DynamicMemoizedFunc (class in RRtoolbox.lib.cache)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.DynamicMemoizedFunc}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.cache.}\bfcode{DynamicMemoizedFunc}}{\emph{func}, \emph{cachedir=None}, \emph{ignore=None}, \emph{mmap\_mode=None}, \emph{compress=False}, \emph{verbose=1}, \emph{timestamp=None}, \emph{banned=False}}{}
Bases: \code{object}
\index{cachedir (RRtoolbox.lib.cache.DynamicMemoizedFunc attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.DynamicMemoizedFunc.cachedir}\pysigline{\bfcode{cachedir}}
\end{fulllineitems}

\index{call\_and\_shelve() (RRtoolbox.lib.cache.DynamicMemoizedFunc method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.DynamicMemoizedFunc.call_and_shelve}\pysiglinewithargsret{\bfcode{call\_and\_shelve}}{\emph{*args}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{clear() (RRtoolbox.lib.cache.DynamicMemoizedFunc method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.DynamicMemoizedFunc.clear}\pysiglinewithargsret{\bfcode{clear}}{\emph{warn=True}}{}
\end{fulllineitems}

\index{compress (RRtoolbox.lib.cache.DynamicMemoizedFunc attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.DynamicMemoizedFunc.compress}\pysigline{\bfcode{compress}}
\end{fulllineitems}

\index{enabled (RRtoolbox.lib.cache.DynamicMemoizedFunc attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.DynamicMemoizedFunc.enabled}\pysigline{\bfcode{enabled}}
\end{fulllineitems}

\index{func (RRtoolbox.lib.cache.DynamicMemoizedFunc attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.DynamicMemoizedFunc.func}\pysigline{\bfcode{func}}
\end{fulllineitems}

\index{ignore (RRtoolbox.lib.cache.DynamicMemoizedFunc attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.DynamicMemoizedFunc.ignore}\pysigline{\bfcode{ignore}}
\end{fulllineitems}

\index{mmap\_mode (RRtoolbox.lib.cache.DynamicMemoizedFunc attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.DynamicMemoizedFunc.mmap_mode}\pysigline{\bfcode{mmap\_mode}}
\end{fulllineitems}

\index{verbose (RRtoolbox.lib.cache.DynamicMemoizedFunc attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.DynamicMemoizedFunc.verbose}\pysigline{\bfcode{verbose}}
\end{fulllineitems}


\end{fulllineitems}

\index{LazyDict (class in RRtoolbox.lib.cache)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.LazyDict}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.cache.}\bfcode{LazyDict}}{\emph{getter}, \emph{dictionary=None}}{}
Bases: \code{\_abcoll.MutableMapping}

Create objects on demand if needed. call the instance with keys to prevent it
from using lazy evaluations (e.g. instead of self{[}key{]} use self(key) to prevent
recursion). Containing operations are safe to prevent recursion (e.g. if key in self
instead of self{[}key{]}). In addition use self.isLazy flag to enable or disable lazy
operations to prevent possible recursions when getter is called.

\end{fulllineitems}

\index{MemoizedDict (class in RRtoolbox.lib.cache)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.MemoizedDict}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.cache.}\bfcode{MemoizedDict}}{\emph{path}, \emph{mode=None}}{}
Bases: \code{\_abcoll.MutableMapping}

memoized dictionary with keys and values persisted to files.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{path}} -- path to save memo file

\item {} 
\textbf{\texttt{mode}} -- loading mode from memo file \{None, `r+', `r', `w+', `c'\}

\end{itemize}

\end{description}\end{quote}

\begin{notice}{warning}{Warning:}
Some data structures cannot be memoize, so this structure is not save yet.
Use at your own risk.
\end{notice}
\index{clear() (RRtoolbox.lib.cache.MemoizedDict method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.MemoizedDict.clear}\pysiglinewithargsret{\bfcode{clear}}{}{}
Remove all items from D.

\end{fulllineitems}


\end{fulllineitems}

\index{Memoizer (class in RRtoolbox.lib.cache)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.Memoizer}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.cache.}\bfcode{Memoizer}}{\emph{ignore=()}, \emph{ignoreAll=False}}{}
Bases: \code{object}
\index{ignore (RRtoolbox.lib.cache.Memoizer attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.Memoizer.ignore}\pysigline{\bfcode{ignore}}
\end{fulllineitems}

\index{makememory() (RRtoolbox.lib.cache.Memoizer method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.Memoizer.makememory}\pysiglinewithargsret{\bfcode{makememory}}{\emph{cachedir=None}, \emph{mmap\_mode=None}, \emph{compress=False}, \emph{verbose=0}}{}
Make memory for {\hyperref[RRtoolbox.lib:RRtoolbox.lib.cache.Memoizer.memoize]{\emph{\code{memoize()}}}} decorator.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{cachedir}} -- path to save metadata, if left None function is not cached.

\item {} 
\textbf{\texttt{mmap\_mode}} -- \{None, `r+', `r', `w+', `c'\}, optional.
The memmapping mode used when loading from cache
numpy arrays. See numpy.load for the meaning of the
arguments.

\item {} 
\textbf{\texttt{compress}} -- (boolean or integer)
Whether to zip the stored data on disk. If an integer is
given, it should be between 1 and 9, and sets the amount
of compression. Note that compressed arrays cannot be
read by memmapping.

\item {} 
\textbf{\texttt{verbose}} -- (int, optional)
Verbosity flag, controls the debug messages that are issued
as functions are evaluated.

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{memoize() (RRtoolbox.lib.cache.Memoizer method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.Memoizer.memoize}\pysiglinewithargsret{\bfcode{memoize}}{\emph{memory=None}, \emph{ignore=None}, \emph{verbose=0}, \emph{mmap\_mode=False}}{}
Decorated functions are faster by trading memory for time, only hashable values can be memoized.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{memory}} -- (Memory or path to folder) if left None function is not cached.

\item {} 
\textbf{\texttt{ignore}} -- (list of strings) A list of arguments name to ignore in the hashing.

\item {} 
\textbf{\texttt{verbose}} -- (integer) Verbosity flag, controls the debug messages that are issued as functions are evaluated.

\item {} 
\textbf{\texttt{mmap\_mode}} -- \{None, `r+', `r', `w+', `c'\}, optional. The memmapping mode used when loading from cache
numpy arrays. See numpy.load for the meaning of the arguments.

\end{itemize}

\item[{Returns}] \leavevmode
decorator

\end{description}\end{quote}

\end{fulllineitems}

\index{memoizers (RRtoolbox.lib.cache.Memoizer attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.Memoizer.memoizers}\pysigline{\bfcode{memoizers}\strong{ = \{140410707069776: \textless{}weakref at 0x7fb3ea29eaf8; to `Memoizer' at 0x7fb3ea514b50\textgreater{}\}}}
\end{fulllineitems}


\end{fulllineitems}

\index{MemorizedFunc (class in RRtoolbox.lib.cache)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.MemorizedFunc}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.cache.}\bfcode{MemorizedFunc}}{\emph{func}, \emph{cachedir}, \emph{ignore=None}, \emph{mmap\_mode=None}, \emph{compress=False}, \emph{verbose=1}, \emph{timestamp=None}}{}
Bases: \code{joblib.memory.MemorizedFunc}

\end{fulllineitems}

\index{Memory (class in RRtoolbox.lib.cache)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.Memory}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.cache.}\bfcode{Memory}}{\emph{cachedir}, \emph{mmap\_mode=None}, \emph{compress=False}, \emph{verbose=1}}{}
Bases: \code{joblib.memory.Memory}

A wrapper to joblib Memory to have better control.

\end{fulllineitems}

\index{NotMemorizedFunc (class in RRtoolbox.lib.cache)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.NotMemorizedFunc}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.cache.}\bfcode{NotMemorizedFunc}}{\emph{func}}{}
Bases: \code{joblib.memory.NotMemorizedFunc}

\end{fulllineitems}

\index{ObjectGetter (class in RRtoolbox.lib.cache)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.ObjectGetter}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.cache.}\bfcode{ObjectGetter}}{\emph{callfunc=None}, \emph{obj=None}, \emph{callback=None}, \emph{**annotations}}{}
Bases: \code{object}

Creates or get instance object depending if it is alive.
\index{create() (RRtoolbox.lib.cache.ObjectGetter method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.ObjectGetter.create}\pysiglinewithargsret{\bfcode{create}}{\emph{throw=False}}{}
Creates an object and keep reference.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{throw}} -- if there is not creation function throws error.

\item[{Returns}] \leavevmode
created object.

\end{description}\end{quote}

\begin{notice}{warning}{Warning:}
previous object reference is lost even if it was alive.
\end{notice}

\begin{notice}{note}{Note:}
Recommended only to use when object from current reference is dead.
\end{notice}

\end{fulllineitems}

\index{getObj() (RRtoolbox.lib.cache.ObjectGetter method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.ObjectGetter.getObj}\pysiglinewithargsret{\bfcode{getObj}}{\emph{throw=False}}{}
\end{fulllineitems}

\index{isAlive() (RRtoolbox.lib.cache.ObjectGetter method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.ObjectGetter.isAlive}\pysiglinewithargsret{\bfcode{isAlive}}{}{}
test if object of reference is alive

\end{fulllineitems}

\index{isCreatable() (RRtoolbox.lib.cache.ObjectGetter method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.ObjectGetter.isCreatable}\pysiglinewithargsret{\bfcode{isCreatable}}{}{}
test if can create object

\end{fulllineitems}

\index{isGettable() (RRtoolbox.lib.cache.ObjectGetter method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.ObjectGetter.isGettable}\pysiglinewithargsret{\bfcode{isGettable}}{}{}
test if object can be gotten either by reference or creation.

\end{fulllineitems}

\index{raw() (RRtoolbox.lib.cache.ObjectGetter method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.ObjectGetter.raw}\pysiglinewithargsret{\bfcode{raw}}{}{}
get object from reference.
:return: None if object is dead, object itself if is alive.

\end{fulllineitems}

\index{update() (RRtoolbox.lib.cache.ObjectGetter method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.ObjectGetter.update}\pysiglinewithargsret{\bfcode{update}}{\emph{**kwargs}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{ResourceManager (class in RRtoolbox.lib.cache)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.ResourceManager}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.cache.}\bfcode{ResourceManager}}{\emph{maxMemory=None}, \emph{margin=0.8}, \emph{unit='MB'}, \emph{all=True}}{}
Bases: {\hyperref[RRtoolbox.lib:RRtoolbox.lib.cache.Retriever]{\emph{\code{RRtoolbox.lib.cache.Retriever}}}}

keep track of references, create objects on demand, manage their memory and optimize for better performance.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{maxMemory}} -- (None) max memory in specified unit to keep in check optimization (it does
not mean that memory never surpasses maxMemory).

\item {} 
\textbf{\texttt{margin}} -- (0.8) margin from maxMemory to trigger optimization.
It is in percentage of maxMemory ranging from 0 (0\%) to maximum 1 (100\%).
So optimal memory is inside range: maxMemory*margin \textless{} Memory \textless{} maxMemory

\item {} 
\textbf{\texttt{unit}} -- (MB) maxMemory unit, it can be GB (Gigabytes), MB (Megabytes), B (bytes)

\item {} 
\textbf{\texttt{all}} -- if True used memory is from all alive references,
if False used memory is only from keptAlive references.

\end{itemize}

\end{description}\end{quote}
\index{all (RRtoolbox.lib.cache.ResourceManager attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.ResourceManager.all}\pysigline{\bfcode{all}}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
all flag, if True: used memory is from all alive references,
if False: used memory is only from keptAlive references.

\end{description}\end{quote}

\end{fulllineitems}

\index{bytes2units() (RRtoolbox.lib.cache.ResourceManager method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.ResourceManager.bytes2units}\pysiglinewithargsret{\bfcode{bytes2units}}{\emph{value}}{}
converts value from bytes to user units

\end{fulllineitems}

\index{getSizeOf() (RRtoolbox.lib.cache.ResourceManager method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.ResourceManager.getSizeOf}\pysiglinewithargsret{\bfcode{getSizeOf}}{\emph{item}}{}
\end{fulllineitems}

\index{keepAlive() (RRtoolbox.lib.cache.ResourceManager method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.ResourceManager.keepAlive}\pysiglinewithargsret{\bfcode{keepAlive}}{\emph{key}, \emph{obj}}{}
\end{fulllineitems}

\index{margin (RRtoolbox.lib.cache.ResourceManager attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.ResourceManager.margin}\pysigline{\bfcode{margin}}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
margin used for triggering memory optimization from maxMemory.

\end{description}\end{quote}

\end{fulllineitems}

\index{maxMemory (RRtoolbox.lib.cache.ResourceManager attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.ResourceManager.maxMemory}\pysigline{\bfcode{maxMemory}}
\end{fulllineitems}

\index{optimizeObject() (RRtoolbox.lib.cache.ResourceManager method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.ResourceManager.optimizeObject}\pysiglinewithargsret{\bfcode{optimizeObject}}{\emph{key}, \emph{getter}, \emph{toWhiteList=False}}{}
\end{fulllineitems}

\index{register() (RRtoolbox.lib.cache.ResourceManager method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.ResourceManager.register}\pysiglinewithargsret{\bfcode{register}}{\emph{key}, \emph{method=None}, \emph{instance=None}}{}
Register object to retrieve.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{key}} -- hashable key to retrieve

\item {} 
\textbf{\texttt{method}} -- callable method to get object

\item {} 
\textbf{\texttt{instance}} -- object instance already created from method

\end{itemize}

\end{description}\end{quote}

\begin{notice}{note}{Note:}
This method is used in \_\_setitem\_\_ as self.register(key, value). Overwrite this
method to change key assignation behaviour.
\end{notice}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{mymethod}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{class} \PYG{n+nc}{constructor}\PYG{p}{:} \PYG{k}{pass}
    \PYG{k}{return} \PYG{n}{constructor}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{ret} \PYG{o}{=} \PYG{n}{retriever}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ret}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{obj}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{mymethod} \PYG{c+c1}{\PYGZsh{} register creating method in \PYGZdq{}obj\PYGZdq{}}
\PYG{n}{im} \PYG{o}{=} \PYG{n}{ret}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{obj}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} get object (created obj +1, with reference)}
\PYG{k}{assert} \PYG{n}{im} \PYG{o+ow}{is} \PYG{n}{ret}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{obj}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} check that it gets the same object}
\PYG{c+c1}{\PYGZsh{} it remembers that \PYGZdq{}obj\PYGZdq{} is last registered or fetched object too}
\PYG{k}{assert} \PYG{n}{ret}\PYG{p}{(}\PYG{p}{)} \PYG{o+ow}{is} \PYG{n}{ret}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} lets register with better control (created obj2 +1, no reference)}
\PYG{n}{ret}\PYG{o}{.}\PYG{n}{register}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{obj2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{mymethod}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{mymethod}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} proves that obj2 is not the same as obj (created obj2 +1, no reference)}
\PYG{k}{assert} \PYG{n}{ret}\PYG{p}{(}\PYG{p}{)} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{n}{ret}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{obj}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{k}{print} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{ret}\PYG{o}{.}\PYG{n}{iteritems}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} get items}
\end{Verbatim}

\end{fulllineitems}

\index{resetGetter() (RRtoolbox.lib.cache.ResourceManager static method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.ResourceManager.resetGetter}\pysiglinewithargsret{\strong{static }\bfcode{resetGetter}}{\emph{getter}}{}
Helper function to reset getter parameters.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{getter}} -- any instance of objectGetter

\end{description}\end{quote}

\end{fulllineitems}

\index{unit (RRtoolbox.lib.cache.ResourceManager attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.ResourceManager.unit}\pysigline{\bfcode{unit}}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
user defined units

\end{description}\end{quote}

\end{fulllineitems}

\index{units2bytes() (RRtoolbox.lib.cache.ResourceManager method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.ResourceManager.units2bytes}\pysiglinewithargsret{\bfcode{units2bytes}}{\emph{value}}{}
converts value from user units two bytes

\end{fulllineitems}

\index{usedMemory (RRtoolbox.lib.cache.ResourceManager attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.ResourceManager.usedMemory}\pysigline{\bfcode{usedMemory}}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
used memory in user units

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Retriever (class in RRtoolbox.lib.cache)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.Retriever}\pysigline{\strong{class }\code{RRtoolbox.lib.cache.}\bfcode{Retriever}}
Bases: \code{\_abcoll.MutableMapping}

keep track of references and create objects on demand if needed.
\index{register() (RRtoolbox.lib.cache.Retriever method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.Retriever.register}\pysiglinewithargsret{\bfcode{register}}{\emph{key}, \emph{method=None}, \emph{instance=None}}{}
Register object to retrieve.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{key}} -- hashable key to retrieve

\item {} 
\textbf{\texttt{method}} -- callable method to get object

\item {} 
\textbf{\texttt{instance}} -- object instance already created from method

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{mymethod}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{class} \PYG{n+nc}{constructor}\PYG{p}{:} \PYG{k}{pass}
    \PYG{k}{return} \PYG{n}{constructor}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{ret} \PYG{o}{=} \PYG{n}{retriever}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ret}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{obj}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{mymethod} \PYG{c+c1}{\PYGZsh{} register creating method in \PYGZdq{}obj\PYGZdq{}}
\PYG{n}{im} \PYG{o}{=} \PYG{n}{ret}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{obj}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} get object (created obj +1, with reference)}
\PYG{k}{assert} \PYG{n}{im} \PYG{o+ow}{is} \PYG{n}{ret}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{obj}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} check that it gets the same object}
\PYG{c+c1}{\PYGZsh{} it remembers that \PYGZdq{}obj\PYGZdq{} is last registered or fetched object too}
\PYG{k}{assert} \PYG{n}{ret}\PYG{p}{(}\PYG{p}{)} \PYG{o+ow}{is} \PYG{n}{ret}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} lets register with better control (created obj2 +1, no reference)}
\PYG{n}{ret}\PYG{o}{.}\PYG{n}{register}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{obj2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{mymethod}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{mymethod}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} proves that obj2 is not the same as obj (created obj2 +1, no reference)}
\PYG{k}{assert} \PYG{n}{ret}\PYG{p}{(}\PYG{p}{)} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{n}{ret}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{obj}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{k}{print} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{ret}\PYG{o}{.}\PYG{n}{iteritems}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} get items}
\end{Verbatim}

\end{fulllineitems}


\end{fulllineitems}

\index{cachedProperty() (in module RRtoolbox.lib.cache)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.cachedProperty}\pysiglinewithargsret{\code{RRtoolbox.lib.cache.}\bfcode{cachedProperty}}{\emph{watch={[}{]}}, \emph{handle={[}{]}}}{}
A memoize decorator of @property decorator specifying what to trigger caching.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{watch}} -- (list of strings) A list of arguments name to watch in the hashing.

\item {} 
\textbf{\texttt{handle}} -- (list of handles or empty list) Provided list is appended with the Memo
handle were data is stored for the method and where a clear() function is provided.

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{mapper() (in module RRtoolbox.lib.cache)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.mapper}\pysiglinewithargsret{\code{RRtoolbox.lib.cache.}\bfcode{mapper}}{\emph{path}, \emph{obj=None}, \emph{mode=None}, \emph{onlynumpy=False}}{}
Save and load or map live objects to disk to free RAM memory.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{path}} -- path to save mapped file.

\item {} 
\textbf{\texttt{obj}} -- the object to map, if None it tries to load obj from path if exist

\item {} 
\textbf{\texttt{mode}} -- \{None, `r+', `r', `w+', `c'\}.

\item {} 
\textbf{\texttt{onlynumpy}} -- if True, it saves a numpy mapper from obj.

\end{itemize}

\item[{Returns}] \leavevmode
mmap image, names of mmap files

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{RRtoolbox.lib.config module}
\label{RRtoolbox.lib:module-RRtoolbox.lib.config}\label{RRtoolbox.lib:rrtoolbox-lib-config-module}\index{RRtoolbox.lib.config (module)}\begin{quote}\begin{description}
\item[{platform}] \leavevmode
Unix, Windows

\item[{synopsis}] \leavevmode
Looking for a reference? look here!.

\end{description}\end{quote}

This module contains all config data to the package.
\index{ConfigTool (class in RRtoolbox.lib.config)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.config.ConfigTool}\pysigline{\strong{class }\code{RRtoolbox.lib.config.}\bfcode{ConfigTool}}
Manage the configured Tools.
\index{getTools() (RRtoolbox.lib.config.ConfigTool static method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.config.ConfigTool.getTools}\pysiglinewithargsret{\strong{static }\bfcode{getTools}}{\emph{package}}{}
Obtains the tools of a directory for the RRtoolbox.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{package}} -- path to the directory or package object.

\item[{Returns}] \leavevmode
a dictionary of imported modules.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{DirectoryManager (class in RRtoolbox.lib.config)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.config.DirectoryManager}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.config.}\bfcode{DirectoryManager}}{\emph{path=None}, \emph{raiseError=True}, \emph{autosave=False}}{}
Bases: \code{object}

Manage the configured variables, paths and files.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{path}} -- (None) path to configuration file. If None uses default path.

\item {} 
\textbf{\texttt{raiseError}} -- True to raise when not attribute in ConfigFile.

\item {} 
\textbf{\texttt{autosave}} -- (True) if True saves at each change.

\end{itemize}

\end{description}\end{quote}

\begin{notice}{note}{Note:}
Any attribute that is not in ConfigFile returns None.
Use raiseError to control this behaviour.
\end{notice}
\index{default (RRtoolbox.lib.config.DirectoryManager attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.config.DirectoryManager.default}\pysigline{\bfcode{default}}
get directories from dictionary representing environment variables.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
dictionary of directories.

\end{description}\end{quote}

\begin{notice}{note}{Note:}
Only directories in the scope of the module are detected.
\end{notice}

\end{fulllineitems}

\index{load() (RRtoolbox.lib.config.DirectoryManager method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.config.DirectoryManager.load}\pysiglinewithargsret{\bfcode{load}}{}{}
loads the configuration file and update.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
loaded configuration file dictionary.

\end{description}\end{quote}

\begin{notice}{warning}{Warning:}
Unsaved instance variables will be replaced by configuration file variables.
\end{notice}

\end{fulllineitems}

\index{reset() (RRtoolbox.lib.config.DirectoryManager method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.config.DirectoryManager.reset}\pysiglinewithargsret{\bfcode{reset}}{}{}
Returns the configuration file to default variables.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
False, if error. Dictionary of new data, if successful.

\end{description}\end{quote}

\begin{notice}{warning}{Warning:}
All custom data is lost in configuration file.
\end{notice}

\begin{notice}{warning}{Warning:}
ConfigFile is purposely not updated. Call manually method load()
\end{notice}

\end{fulllineitems}

\index{save() (RRtoolbox.lib.config.DirectoryManager method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.config.DirectoryManager.save}\pysiglinewithargsret{\bfcode{save}}{\emph{mode=0}}{}
saves configuration file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{mode}} -- 0- delete and save, 1- update without replace,
2- update replacing variables.

\item[{Returns}] \leavevmode
False, if error. Dictionary of new data, if successful.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{findModules() (in module RRtoolbox.lib.config)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.config.findModules}\pysiglinewithargsret{\code{RRtoolbox.lib.config.}\bfcode{findModules}}{\emph{package}, \emph{exclude=None}}{}
Find modules from a package.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{package}} -- imported packaged or path (str).

\item {} 
\textbf{\texttt{exclude}} -- list of modules to exclude.

\end{itemize}

\item[{Returns}] \leavevmode
dictionary containing importer, ispkg

\end{description}\end{quote}

\end{fulllineitems}

\index{getModules() (in module RRtoolbox.lib.config)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.config.getModules}\pysiglinewithargsret{\code{RRtoolbox.lib.config.}\bfcode{getModules}}{\emph{package}, \emph{exclude=None}}{}
Import modules from a package.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{package}} -- imported packaged or path (str).

\item[{Returns}] \leavevmode
dictionary containing imported modules.

\end{description}\end{quote}

\end{fulllineitems}

\index{getPackagePath() (in module RRtoolbox.lib.config)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.config.getPackagePath}\pysiglinewithargsret{\code{RRtoolbox.lib.config.}\bfcode{getPackagePath}}{\emph{package}}{}
Get the path of a package object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{package}} -- package object or path (str).

\item[{Returns}] \leavevmode
path to the package.

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{RRtoolbox.lib.descriptors module}
\label{RRtoolbox.lib:module-RRtoolbox.lib.descriptors}\label{RRtoolbox.lib:rrtoolbox-lib-descriptors-module}\index{RRtoolbox.lib.descriptors (module)}\index{ASIFT() (in module RRtoolbox.lib.descriptors)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.descriptors.ASIFT}\pysiglinewithargsret{\code{RRtoolbox.lib.descriptors.}\bfcode{ASIFT}}{\emph{feature\_name}, \emph{img}, \emph{mask=None}, \emph{pool=\textless{}multiprocessing.pool.ThreadPool object\textgreater{}}}{}
asift(feature\_name, img, mask=None, pool=None) -\textgreater{} keypoints, descrs

Apply a set of affine transformations to the image, detect keypoints and
reproject them into initial image coordinates.
See \href{http://www.ipol.im/pub/algo/my\_affine\_sift/}{http://www.ipol.im/pub/algo/my\_affine\_sift/} for the details.

ThreadPool object may be passed to speedup the computation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{feature\_name}} -- feature name to create detector.

\item {} 
\textbf{\texttt{img}} -- image to find keypoints and its descriptors

\item {} 
\textbf{\texttt{mask}} -- mask to detect keypoints (it uses default, mask{[}:{]} = 255)

\item {} 
\textbf{\texttt{pool}} -- multiprocessing pool (dummy, it uses multithreading)

\end{itemize}

\item[{Returns}] \leavevmode
keypoints,descriptors

\end{description}\end{quote}

\end{fulllineitems}

\index{ASIFT\_iter() (in module RRtoolbox.lib.descriptors)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.descriptors.ASIFT_iter}\pysiglinewithargsret{\code{RRtoolbox.lib.descriptors.}\bfcode{ASIFT\_iter}}{\emph{imgs}, \emph{feature\_name='sift-flann'}}{}
Affine-SIFT for N images.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{imgs}} -- images to apply asift

\item {} 
\textbf{\texttt{feature\_name}} -- eg. SIFT SURF ORB

\end{itemize}

\item[{Returns}] \leavevmode
{[}(kp1,desc1),...,(kpN,descN){]}

\end{description}\end{quote}

\end{fulllineitems}

\index{ASIFT\_multiple() (in module RRtoolbox.lib.descriptors)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.descriptors.ASIFT_multiple}\pysiglinewithargsret{\code{RRtoolbox.lib.descriptors.}\bfcode{ASIFT\_multiple}}{\emph{imgs}, \emph{feature\_name='sift-flann'}}{}
Affine-SIFT for N images.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{imgs}} -- images to apply asift

\item {} 
\textbf{\texttt{feature\_name}} -- eg. SIFT SURF ORB

\end{itemize}

\item[{Returns}] \leavevmode
{[}(kp1,desc1),...,(kpN,descN){]}

\end{description}\end{quote}

\end{fulllineitems}

\index{Feature (class in RRtoolbox.lib.descriptors)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.descriptors.Feature}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.descriptors.}\bfcode{Feature}}{\emph{pool=\textless{}multiprocessing.pool.ThreadPool object\textgreater{}}, \emph{useASIFT=True}, \emph{debug=True}}{}
Bases: \code{object}

Class to manage detection and computation of features
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{pool}} -- multiprocessing pool (dummy, it uses multithreading)

\item {} 
\textbf{\texttt{useASIFT}} -- if True adds Affine perspectives to the detector.

\item {} 
\textbf{\texttt{debug}} -- if True prints to the stdout debug messages.

\end{itemize}

\end{description}\end{quote}
\index{config() (RRtoolbox.lib.descriptors.Feature method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.descriptors.Feature.config}\pysiglinewithargsret{\bfcode{config}}{\emph{name}, \emph{separator='-`}}{}
This function takes parameters from a command to initialize a detector and matcher.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{name}} -- ``{[}a-{]}\textless{}sift\textbar{}surf\textbar{}orb\textgreater{}{[}-flann{]}'' (str) Ex: ``a-sift-flann''

\item {} 
\textbf{\texttt{features}} -- it is a dictionary containing the mapping from name to the
initialized detector, matcher pair. If None it is created.
This feature is to reduce time by reusing created features.

\end{itemize}

\item[{Returns}] \leavevmode
detector, matcher

\end{description}\end{quote}

\end{fulllineitems}

\index{detectAndCompute() (RRtoolbox.lib.descriptors.Feature method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.descriptors.Feature.detectAndCompute}\pysiglinewithargsret{\bfcode{detectAndCompute}}{\emph{img}, \emph{mask=None}}{}
detect keypoints and descriptors
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{img}} -- image to find keypoints and its descriptors

\item {} 
\textbf{\texttt{mask}} -- mask to detect keypoints (it uses default, mask{[}:{]} = 255)

\end{itemize}

\item[{Returns}] \leavevmode
keypoints,descriptors

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{MATCH() (in module RRtoolbox.lib.descriptors)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.descriptors.MATCH}\pysiglinewithargsret{\code{RRtoolbox.lib.descriptors.}\bfcode{MATCH}}{\emph{feature\_name}, \emph{kp1}, \emph{desc1}, \emph{kp2}, \emph{desc2}}{}
Use matcher and asift output to obtain Transformation matrix (TM).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{feature\_name}} -- feature name to create detector. It is the same used in the detector
which is used in init\_feature function but the detector itself is ignored.
e.g. if `detector' uses BFMatcher, if `detector-flann' uses FlannBasedMatcher.

\item {} 
\textbf{\texttt{kp1}} -- keypoints of source image

\item {} 
\textbf{\texttt{desc1}} -- descriptors of kp1

\item {} 
\textbf{\texttt{kp2}} -- keypoints of destine image

\item {} 
\textbf{\texttt{desc2}} -- descriptors of kp2

\end{itemize}

\item[{Returns}] \leavevmode
TM

\end{description}\end{quote}

\# \href{http://docs.opencv.org/3.0-beta/doc/py\_tutorials/py\_feature2d/py\_feature\_homography/py\_feature\_homography.html}{http://docs.opencv.org/3.0-beta/doc/py\_tutorials/py\_feature2d/py\_feature\_homography/py\_feature\_homography.html}

\end{fulllineitems}

\index{MATCH\_multiple() (in module RRtoolbox.lib.descriptors)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.descriptors.MATCH_multiple}\pysiglinewithargsret{\code{RRtoolbox.lib.descriptors.}\bfcode{MATCH\_multiple}}{\emph{pairlist}, \emph{feature\_name='sift-flann'}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{pairlist}} -- list of keypoint and descriptors pair e.g. {[}(kp1,desc1),...,(kpN,descN){]}

\item {} 
\textbf{\texttt{feature\_name}} -- feature name to create detector

\end{itemize}

\item[{Returns}] \leavevmode
{[}(H1, mask1, kp\_pairs1),....(HN, maskN, kp\_pairsN){]}

\end{description}\end{quote}

\end{fulllineitems}

\index{affine\_skew() (in module RRtoolbox.lib.descriptors)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.descriptors.affine_skew}\pysiglinewithargsret{\code{RRtoolbox.lib.descriptors.}\bfcode{affine\_skew}}{\emph{tilt}, \emph{phi}, \emph{img}, \emph{mask=None}}{}
Increase robustness to descriptors by calculating other invariant perspectives to image.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{tilt}} -- tilting of image

\item {} 
\textbf{\texttt{phi}} -- rotation of image (in degrees)

\item {} 
\textbf{\texttt{img}} -- image to find Affine transforms

\item {} 
\textbf{\texttt{mask}} -- mask to detect keypoints (it uses default, mask{[}:{]} = 255)

\end{itemize}

\item[{Returns}] \leavevmode
skew\_img, skew\_mask, Ai (invert Affine Transform)

\end{description}\end{quote}

Ai - is an affine transform matrix from skew\_img to img

\end{fulllineitems}

\index{filter\_matches() (in module RRtoolbox.lib.descriptors)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.descriptors.filter_matches}\pysiglinewithargsret{\code{RRtoolbox.lib.descriptors.}\bfcode{filter\_matches}}{\emph{kp1}, \emph{kp2}, \emph{matches}, \emph{ratio=0.75}}{}
This function applies a ratio test.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{kp1}} -- raw keypoints 1

\item {} 
\textbf{\texttt{kp2}} -- raw keypoints 2

\item {} 
\textbf{\texttt{matches}} -- raw matches

\item {} 
\textbf{\texttt{ratio}} -- filtering ratio of distance

\end{itemize}

\item[{Returns}] \leavevmode
filtered keypoint 1, filtered keypoint 2, keypoint pairs

\end{description}\end{quote}

\end{fulllineitems}

\index{init\_feature() (in module RRtoolbox.lib.descriptors)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.descriptors.init_feature}\pysiglinewithargsret{\code{RRtoolbox.lib.descriptors.}\bfcode{init\_feature}}{\emph{name}, \emph{features=None}}{}
This function takes parameters from a command to initialize a detector and matcher.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{name}} -- ``\textless{}sift\textbar{}surf\textbar{}orb\textgreater{}{[}-flann{]}'' (str) Ex: ``sift-flann''

\item {} 
\textbf{\texttt{features}} -- it is a dictionary containing the mapping from name to the
initialized detector, matcher pair. If None it is created.
This feature is to reduce time by reusing created features.

\end{itemize}

\item[{Returns}] \leavevmode
detector, matcher

\end{description}\end{quote}

\end{fulllineitems}

\index{inlineRatio() (in module RRtoolbox.lib.descriptors)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.descriptors.inlineRatio}\pysiglinewithargsret{\code{RRtoolbox.lib.descriptors.}\bfcode{inlineRatio}}{\emph{inlines}, \emph{lines}, \emph{thresh=30}}{}
Probability that a match was correct.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{inlines}} -- number of matched lines

\item {} 
\textbf{\texttt{lines}} -- number lines

\item {} 
\textbf{\texttt{thresh}} -- threshold for lines (i.e. very low probability \textless{}= thresh \textless{} good probability)

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{RRtoolbox.lib.directory module}
\label{RRtoolbox.lib:module-RRtoolbox.lib.directory}\label{RRtoolbox.lib:rrtoolbox-lib-directory-module}\index{RRtoolbox.lib.directory (module)}
This module holds all path manipulation methods and a string concept called directory (referenced paths and strings)
designed to support \code{config} and be used with \code{session}.


\paragraph{keywords:}
\label{RRtoolbox.lib:keywords}
\emph{path}: it can be to a folder or file or url if specified
\emph{filename}: the file name without its path
\emph{filepath}: the path to a file
\emph{dirname}: the path to a folder
\emph{url}: Universal Resource Locator
\index{Directory (class in RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.Directory}\pysigline{\strong{class }\code{RRtoolbox.lib.directory.}\bfcode{Directory}}
Bases: \code{str}

semi-mutable string representation of a inmutable string with support for path representations.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} -- list, directory instance, dictionary or string.

\item {} 
\textbf{\texttt{ispath}} -- True to add support for paths.

\item {} 
\textbf{\texttt{copy}} -- when data is a directory if copy is True then this instance data is independent
of the passed directory otherwise both directories are a reference to the same
dictionary data but they are not the same object.

\item {} 
\textbf{\texttt{kwargs}} -- additional data to add in directory.

\end{itemize}

\end{description}\end{quote}
\index{copy() (RRtoolbox.lib.directory.Directory method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.Directory.copy}\pysiglinewithargsret{\bfcode{copy}}{}{}
Creates copy of itself.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
non-referenced directory copy.

\end{description}\end{quote}

\end{fulllineitems}

\index{correctSTRBuiltin() (RRtoolbox.lib.directory.Directory method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.Directory.correctSTRBuiltin}\pysiglinewithargsret{\bfcode{correctSTRBuiltin}}{}{}
Decorate all the built-in functions of class directory.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
built-in decorated function.

\end{description}\end{quote}

\end{fulllineitems}

\index{filterdata() (RRtoolbox.lib.directory.Directory static method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.Directory.filterdata}\pysiglinewithargsret{\strong{static }\bfcode{filterdata}}{\emph{data}, \emph{ispath=None}, \emph{kwargs=None}}{}
Adequate data for dictionary creation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} -- any supported object.

\item {} 
\textbf{\texttt{ispath}} -- True to add support for paths.

\item {} 
\textbf{\texttt{kwargs}} -- additional data to add in directory.

\end{itemize}

\item[{Returns}] \leavevmode
dictionary

\end{description}\end{quote}

\end{fulllineitems}

\index{repr2list() (RRtoolbox.lib.directory.Directory static method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.Directory.repr2list}\pysiglinewithargsret{\strong{static }\bfcode{repr2list}}{\emph{data}, \emph{level=0}}{}
Converts the representation of a directory.repr to pickleable.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{data}} -- directory.repr of the form {[}''string'',directory,...,directory.repr{]}.

\item[{Returns}] \leavevmode
pickleable list.

\end{description}\end{quote}

\end{fulllineitems}

\index{repr2str() (RRtoolbox.lib.directory.Directory static method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.Directory.repr2str}\pysiglinewithargsret{\strong{static }\bfcode{repr2str}}{\emph{data}, \emph{ispath=True}}{}
Converts the representation of a directory.repr to string.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{data}} -- directory.repr of the form {[}''string'',directory,...,directory.repr{]}.

\item[{Returns}] \leavevmode
converted string.

\end{description}\end{quote}

\end{fulllineitems}

\index{update() (RRtoolbox.lib.directory.Directory method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.Directory.update}\pysiglinewithargsret{\bfcode{update}}{\emph{data=None}}{}
Return an updated copy with provided data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{data}} -- any supported object.
If None return updated and referenced copy of itself.

\item[{Returns}] \leavevmode
new directory referenced to itself.

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_left() (RRtoolbox.lib.directory.Directory method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.Directory.update_left}\pysiglinewithargsret{\bfcode{update\_left}}{\emph{other}}{}
Updates representation a the left.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} -- any supported object.

\item[{Returns}] \leavevmode
new directory referenced to itself.

\end{description}\end{quote}

\begin{notice}{note}{Note:}
Equivalent to self - other e.g. directory({[}other, self{]})
\end{notice}

\end{fulllineitems}

\index{update\_right() (RRtoolbox.lib.directory.Directory method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.Directory.update_right}\pysiglinewithargsret{\bfcode{update\_right}}{\emph{other}}{}
Updates representation a the right.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} -- any supported object.

\item[{Returns}] \leavevmode
new directory referenced to itself.

\end{description}\end{quote}

\begin{notice}{note}{Note:}
Equivalent to self + other e.g. directory({[}self, other{]})
\end{notice}

\end{fulllineitems}


\end{fulllineitems}

\index{FileDirectory (class in RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.FileDirectory}\pysigline{\strong{class }\code{RRtoolbox.lib.directory.}\bfcode{FileDirectory}}
Bases: {\hyperref[RRtoolbox.lib:RRtoolbox.lib.directory.Directory]{\emph{\code{RRtoolbox.lib.directory.Directory}}}}

Saves contents of a file as with directories.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} -- list, directory instance, dictionary or string.

\item {} 
\textbf{\texttt{filename}} -- name of file.

\item {} 
\textbf{\texttt{path}} -- path to folder where file is (it must finish in /).

\item {} 
\textbf{\texttt{notes}} -- optional description string

\item {} 
\textbf{\texttt{kwargs}} -- additional data to add in directory.

\end{itemize}

\end{description}\end{quote}
\index{makeFile() (RRtoolbox.lib.directory.FileDirectory method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.FileDirectory.makeFile}\pysiglinewithargsret{\bfcode{makeFile}}{}{}
Makes a file with its contents to path/filename.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
True if successful

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{changedir() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.changedir}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{changedir}}{\emph{filepath}, \emph{dirname}, \emph{ext=True}}{}
Change path to file with dirname.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{filepath}} -- path to file.

\item {} 
\textbf{\texttt{dirname}} -- new path to replace in filepath.

\item {} 
\textbf{\texttt{ext}} -- True to keep extension of file if any.

\end{itemize}

\item[{Returns}] \leavevmode
directory object of changed path.

\end{description}\end{quote}

\end{fulllineitems}

\index{checkDir() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.checkDir}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{checkDir}}{\emph{dirname}}{}
checks if dirname exists.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{dirname}} -- path to folder

\item[{Returns}] \leavevmode
True if exits, False if not

\end{description}\end{quote}

\end{fulllineitems}

\index{checkFile() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.checkFile}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{checkFile}}{\emph{path}}{}
checks if filepath or filename exists.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{path}} -- filepath or filename

\item[{Returns}] \leavevmode
True if exits, False if not

\end{description}\end{quote}

\end{fulllineitems}

\index{checkPath() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.checkPath}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{checkPath}}{\emph{path}}{}
checks if path exists.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{path}} -- path to folder or file.

\item[{Returns}] \leavevmode
True if exits, False if not

\end{description}\end{quote}

\end{fulllineitems}

\index{checkURL() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.checkURL}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{checkURL}}{\emph{url}}{}
checks if url exists.
:param url: path to url
:return: True if exits, False if not

\end{fulllineitems}

\index{correctPath() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.correctPath}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{correctPath}}{\emph{path}, \emph{relative}}{}
Get path corrected from its relative path or level index.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{path}} -- path or file name.

\item {} 
\textbf{\texttt{relative}} -- pattern or level in directory.

\end{itemize}

\item[{Returns}] \leavevmode
corrected path.

\end{description}\end{quote}

\end{fulllineitems}

\index{correctSep() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.correctSep}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{correctSep}}{\emph{path='/mnt/4E443F99443F82AF/Dropbox/PYTHON/RRtools/RRtoolbox/lib/directory.pyc'}, \emph{separator='/'}}{}
Replaces the path separators by custom or OS standard separator.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{path}} -- relative or absolute path (str). Default is \_\_file\_\_ or module's path.

\item {} 
\textbf{\texttt{separator}} -- desired separators, By default uses system separator (os.path.sep).

\end{itemize}

\item[{Returns}] \leavevmode
path with corrected separator.

\end{description}\end{quote}

\end{fulllineitems}

\index{decoratePath() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.decoratePath}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{decoratePath}}{\emph{relative}, \emph{sep='/'}}{}
Decorated path is controlled to give absolute path from relative path.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{relative}} -- int or path.

\item {} 
\textbf{\texttt{sep}} -- path separator

\end{itemize}

\item[{Returns}] \leavevmode
decorator

\end{description}\end{quote}

\end{fulllineitems}

\index{getData() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.getData}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{getData}}{\emph{path='/mnt/4E443F99443F82AF/Dropbox/PYTHON/RRtools/RRtoolbox/lib/directory.pyc'}}{}
Get standard path from path.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{path}} -- it can be to a folder or file. Default is \_\_file\_\_ or module's path.

\item[{Returns}] \leavevmode
{[}drive,dirname,filename,ext{]}.
1. drive or UNC (Universal Naming Convention)
2. dirname is path to folder.
3. filename is name of file.
4. ext is extension of file.

\end{description}\end{quote}

\end{fulllineitems}

\index{getFileHandle() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.getFileHandle}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{getFileHandle}}{\emph{path}}{}
Gets a file handle from url or disk file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{path}} -- filepath or url

\item[{Returns}] \leavevmode
file object

\end{description}\end{quote}

\end{fulllineitems}

\index{getFileSize() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.getFileSize}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{getFileSize}}{\emph{path}}{}
Gets a size from url or disk file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{path}} -- filepath or url

\item[{Returns}] \leavevmode
size in bytes

\end{description}\end{quote}

\end{fulllineitems}

\index{getPath() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.getPath}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{getPath}}{\emph{path='/mnt/4E443F99443F82AF/Dropbox/PYTHON/RRtools/RRtoolbox/lib/directory.pyc'}}{}
Get standard path from path.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{path}} -- it can be to a folder or file. Default is \_\_file\_\_ or module's path.
If file exists it selects its folder.

\item[{Returns}] \leavevmode
dirname (path to a folder)

\end{description}\end{quote}

\begin{notice}{note}{Note:}
It is the same as os.path.dirname(os.path.abspath(path)).
\end{notice}

\end{fulllineitems}

\index{getSep() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.getSep}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{getSep}}{\emph{path}, \emph{pattern='/\textbackslash{}\textbackslash{}'}}{}
Get path separator or indicator.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{path}} -- relative or absolute path (str).

\item {} 
\textbf{\texttt{pattern}} -- guess characters to compare path (str).

\end{itemize}

\item[{Returns}] \leavevmode
sep (str).

\end{description}\end{quote}

\begin{notice}{note}{Note:}
It is equivalent to os.path.sep but obtained from the given path and patterns.
\end{notice}

\end{fulllineitems}

\index{getShortenedPath() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.getShortenedPath}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{getShortenedPath}}{\emph{path}, \emph{comp}}{}
Path is controlled to give absolute path from relative path or integer.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{path}} -- absolute path (str).

\item {} 
\textbf{\texttt{comp}} -- pattern or relative path (str) or integer representing level of folder
determined by the separator Ex. ``/level 1/level 2/.../level N or -1''.

\end{itemize}

\item[{Returns}] \leavevmode
path before matched to comp  Ex: ``C://level 1//comp --\textgreater{} C://level 1''

\end{description}\end{quote}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{path} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LEVEL1/LEVEL2/LEVEL3/LEVEL4/LEVEL5}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{getShortenedPath}\PYG{p}{(}\PYG{n}{path}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} minus two levels}
\PYG{g+go}{LEVEL1/LEVEL2/LEVEL3}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{getShortenedPath}\PYG{p}{(}\PYG{n}{path}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} until three levels}
\PYG{g+go}{LEVEL1/LEVEL2}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{getShortenedPath}\PYG{p}{(}\PYG{n}{path}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LEVEL1/LEVEL2/LEVEL3/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{LEVEL1/LEVEL2/LEVEL3/}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{getShortenedPath}\PYG{p}{(}\PYG{n}{path}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LEVEL4/REPLACE5/NEWLEVEL}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{LEVEL1/LEVEL2/LEVEL3/LEVEL4/REPLACE5/NEWLEVEL}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{getShortenedPath}\PYG{p}{(}\PYG{n}{path}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../../SHOULD\PYGZus{}BE\PYGZus{}LEVEL4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{LEVEL1/LEVEL2/LEVEL3/SHOULD\PYGZus{}BE\PYGZus{}LEVEL4}
\end{Verbatim}

\end{fulllineitems}

\index{getSplitted() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.getSplitted}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{getSplitted}}{\emph{path='/mnt/4E443F99443F82AF/Dropbox/PYTHON/RRtools/RRtoolbox/lib/directory.pyc'}}{}
Splits a file path by its separators.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{path}} -- it can be to a folder or file. Default is \_\_file\_\_ or module's path.

\item[{Returns}] \leavevmode
splitted path.

\end{description}\end{quote}

\end{fulllineitems}

\index{increment\_if\_exits() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.increment_if_exits}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{increment\_if\_exits}}{\emph{path}, \emph{add='\_\{num\}'}, \emph{force=None}}{}
Generates new name if it exits.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{path}} -- absolute path or filename

\item {} 
\textbf{\texttt{add}} -- if fn exists add pattern

\item {} 
\textbf{\texttt{force}} -- (None) force existent files even if they don't. if True
treats fn as existent or if it is a list it treats names from
the list as existent names.

\end{itemize}

\item[{Returns}] \leavevmode
un-existent fn

\end{description}\end{quote}

\end{fulllineitems}

\index{joinPath() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.joinPath}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{joinPath}}{\emph{absolute}, \emph{relative}}{}
Joins an absolute path to a relative path.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{absolute}} -- directory or path.

\item {} 
\textbf{\texttt{relative}} -- directory or path.

\end{itemize}

\item[{Returns}] \leavevmode
joined path.

\end{description}\end{quote}

\begin{notice}{note}{Note:}
It is equivalent to os.path.join but works with directories.
\end{notice}

\end{fulllineitems}

\index{mkPath() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.mkPath}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{mkPath}}{\emph{path}}{}
Make path (i.e. creating folder) for filepath.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{path}} -- path to nonexistent folder or file.

\item[{Returns}] \leavevmode
created path.

\end{description}\end{quote}

\end{fulllineitems}

\index{quickOps() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.quickOps}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{quickOps}}{\emph{path}, \emph{comp}}{}
(IN DEVELOPMENT) make quick matching operations in path.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{path}} -- path to folder

\item {} 
\textbf{\texttt{comp}} -- pattern

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

Requirements:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{path} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LEVEL1/LEVEL2/LEVEL3/LEVEL4/LEVEL5}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{print} \PYG{n}{quickOps}\PYG{p}{(}\PYG{n}{path}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../ROOT/../LEVEL1/../LEVEL2/LEVEL3/../../LEVEL4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LEVEL4}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{print} \PYG{n}{quickOps}\PYG{p}{(}\PYG{n}{path}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ROOT/../LEVEL1/LEVEL2/../../LEVEL4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LEVEL3/LEVEL4}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{print} \PYG{n}{quickOps}\PYG{p}{(}\PYG{n}{path}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../LEVEL2/../}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LEVEL1/LEVEL3/LEVEL4/LEVEL5}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{print} \PYG{n}{quickOps}\PYG{p}{(}\PYG{n}{path}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../LEVEL2/..}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LEVEL1/LEVEL3/LEVEL4/LEVEL5/}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{print} \PYG{n}{quickOps}\PYG{p}{(}\PYG{n}{path}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LEVEL2/../../LEVEL4/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LEVEL2/LEVEL3/LEVEL4/}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{print} \PYG{n}{quickOps}\PYG{p}{(}\PYG{n}{path}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ROOT/../LEVEL2/../../LEVEL4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ROOT/LEVEL3/LEVEL4}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{print} \PYG{n}{quickOps}\PYG{p}{(}\PYG{n}{path}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LEVEL\PYGZhy{}1/../NEW7/LEVEL8}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LEVEL\PYGZhy{}1/LEVEL1/LEVEL2/LEVEL3/LEVEL4/LEVEL5/NEW7/LEVEL8}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{print}
\end{Verbatim}

\end{fulllineitems}

\index{resource\_path() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.resource_path}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{resource\_path}}{\emph{relative\_path='`}}{}
Get absolute path to resource, works for dev and for PyInstaller

\end{fulllineitems}

\index{rmFile() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.rmFile}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{rmFile}}{\emph{filepath}}{}
Remove file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{filepath}} -- path to file.

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{rmPath() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.rmPath}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{rmPath}}{\emph{path}, \emph{ignore\_errors=False}, \emph{onerror=None}}{}
Remove path from path.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{path}} -- path to nonexistent folder or file.

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}


\strong{See also:}


shutil.rmtree



\end{fulllineitems}

\index{strdifference() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.strdifference}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{strdifference}}{\emph{s1}, \emph{s2}}{}
Get string differences.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{s1}} -- string 1

\item {} 
\textbf{\texttt{s2}} -- string 2

\end{itemize}

\item[{Returns}] \leavevmode
(splitted string 1, splitted string 2, index).
A splitted string is a list with the string parts.
Index is a list containing the indexes of different parts of the two splitted strings.

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{RRtoolbox.lib.image module}
\label{RRtoolbox.lib:rrtoolbox-lib-image-module}\phantomsection\label{RRtoolbox.lib:module-RRtoolbox.lib.image}\index{RRtoolbox.lib.image (module)}
Bundle of methods for handling images. Rather than manipulating specialized
operations in images methods in this module are used for loading, outputting
and format-converting methods, as well as color manipulation.

SUPPORTED FORMATS

see \href{http://docs.opencv.org/2.4/modules/highgui/doc/reading\_and\_writing\_images\_and\_video.html\#imread}{http://docs.opencv.org/2.4/modules/highgui/doc/reading\_and\_writing\_images\_and\_video.html\#imread}

Windows bitmaps - {\color{red}\bfseries{}*}.bmp, {\color{red}\bfseries{}*}.dib (always supported)
JPEG files - {\color{red}\bfseries{}*}.jpeg, {\color{red}\bfseries{}*}.jpg, {\color{red}\bfseries{}*}.jpe (see the Notes section)
JPEG 2000 files - {\color{red}\bfseries{}*}.jp2 (see the Notes section)
Portable Network Graphics - {\color{red}\bfseries{}*}.png (see the Notes section)
Portable image format - {\color{red}\bfseries{}*}.pbm, {\color{red}\bfseries{}*}.pgm, {\color{red}\bfseries{}*}.ppm (always supported)
Sun rasters - {\color{red}\bfseries{}*}.sr, {\color{red}\bfseries{}*}.ras (always supported)
TIFF files - {\color{red}\bfseries{}*}.tiff, {\color{red}\bfseries{}*}.tif (see the Notes section)
\index{GetCoors (class in RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.GetCoors}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.image.}\bfcode{GetCoors}}{\emph{im}, \emph{win='get coordinates'}, \emph{updatefunc=\textless{}function drawcoorpoints\textgreater{}}, \emph{unique=True}, \emph{col\_out=(0}, \emph{0}, \emph{0)}, \emph{col\_in=(0}, \emph{0}, \emph{255)}}{}
Bases: {\hyperref[RRtoolbox.lib:RRtoolbox.lib.plotter.Plotim]{\emph{\code{RRtoolbox.lib.plotter.Plotim}}}}

Create window to select points from image.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{im}} -- image to get points.

\item {} 
\textbf{\texttt{win}} -- window name.

\item {} 
\textbf{\texttt{updatefunc}} -- function to draw interaction with points.
(e.g. limitaxispoints, drawcoorperspective, etc.).

\item {} 
\textbf{\texttt{prox}} -- proximity to identify point.

\item {} 
\textbf{\texttt{radius}} -- radius of drawn points.

\item {} 
\textbf{\texttt{unique}} -- If True no point can be repeated,
else selected points can be repeated.

\item {} 
\textbf{\texttt{col\_out}} -- outer color of point.

\item {} 
\textbf{\texttt{col\_in}} -- inner color of point.

\end{itemize}

\end{description}\end{quote}
\index{coors (RRtoolbox.lib.image.GetCoors attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.GetCoors.coors}\pysigline{\bfcode{coors}}
\end{fulllineitems}

\index{drawstats() (RRtoolbox.lib.image.GetCoors method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.GetCoors.drawstats}\pysiglinewithargsret{\bfcode{drawstats}}{\emph{points}, \emph{col\_out=(0}, \emph{0}, \emph{0)}, \emph{col\_in=(0}, \emph{255}, \emph{0)}, \emph{radius=2}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{self}} -- 

\item {} 
\textbf{\texttt{points}} -- 

\item {} 
\textbf{\texttt{col\_out}} -- 

\item {} 
\textbf{\texttt{col\_in}} -- 

\item {} 
\textbf{\texttt{radius}} -- 

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{mousefunc() (RRtoolbox.lib.image.GetCoors method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.GetCoors.mousefunc}\pysiglinewithargsret{\bfcode{mousefunc}}{}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{updatecoors() (RRtoolbox.lib.image.GetCoors method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.GetCoors.updatecoors}\pysiglinewithargsret{\bfcode{updatecoors}}{}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ImCoors (class in RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.ImCoors}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.image.}\bfcode{ImCoors}}{\emph{pts}, \emph{dtype=\textless{}type `numpy.float32'\textgreater{}}, \emph{deg=False}}{}
Bases: \code{object}

Image's coordinates class.
Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{n}{ImCoors}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{116}\PYG{p}{,} \PYG{l+m+mi}{161}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{295}\PYG{p}{,} \PYG{l+m+mi}{96}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{122}\PYG{p}{,} \PYG{l+m+mi}{336}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{291}\PYG{p}{,} \PYG{l+m+mi}{286}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{a}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}dict\PYGZus{}\PYGZus{}}
\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{mean depend on min and max: }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{a}\PYG{o}{.}\PYG{n}{mean}
\PYG{k}{print} \PYG{n}{a}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}dict\PYGZus{}\PYGZus{}}
\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{after mean max has been already been calculated: }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{a}\PYG{o}{.}\PYG{n}{max}
\PYG{n}{a}\PYG{o}{.}\PYG{n}{data} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{116}\PYG{p}{,} \PYG{l+m+mi}{161}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{295}\PYG{p}{,} \PYG{l+m+mi}{96}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{a}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}dict\PYGZus{}\PYGZus{}}
\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{mean and all its dependencies are processed again: }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{a}\PYG{o}{.}\PYG{n}{mean}
\end{Verbatim}
\index{dtype (RRtoolbox.lib.image.ImCoors attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.ImCoors.dtype}\pysigline{\bfcode{dtype}}
\end{fulllineitems}

\index{pts (RRtoolbox.lib.image.ImCoors attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.ImCoors.pts}\pysigline{\bfcode{pts}}
\end{fulllineitems}


\end{fulllineitems}

\index{ImFactory (class in RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.ImFactory}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.image.}\bfcode{ImFactory}}{\emph{**kwargs}}{}
image factory for RRToolbox to create scripts to standardize loading images and
provide lazy loading (it can load images from disk with the customized options
and/or create mapping images to load when needed) to conserve memory.

\begin{notice}{warning}{Warning:}
In development.
\end{notice}
\index{get\_Func() (RRtoolbox.lib.image.ImFactory method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.ImFactory.get_Func}\pysiglinewithargsret{\bfcode{get\_Func}}{}{}
gets the loading function

\end{fulllineitems}

\index{get\_code() (RRtoolbox.lib.image.ImFactory method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.ImFactory.get_code}\pysiglinewithargsret{\bfcode{get\_code}}{}{}
get the script code

\end{fulllineitems}

\index{get\_convertionFunc() (RRtoolbox.lib.image.ImFactory method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.ImFactory.get_convertionFunc}\pysiglinewithargsret{\bfcode{get\_convertionFunc}}{\emph{code}}{}
\end{fulllineitems}

\index{get\_errorFunc() (RRtoolbox.lib.image.ImFactory method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.ImFactory.get_errorFunc}\pysiglinewithargsret{\bfcode{get\_errorFunc}}{\emph{path=None}, \emph{throw=None}}{}
\end{fulllineitems}

\index{get\_loadFunc() (RRtoolbox.lib.image.ImFactory method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.ImFactory.get_loadFunc}\pysiglinewithargsret{\bfcode{get\_loadFunc}}{\emph{flag=None}}{}
\end{fulllineitems}

\index{get\_mapFunc() (RRtoolbox.lib.image.ImFactory method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.ImFactory.get_mapFunc}\pysiglinewithargsret{\bfcode{get\_mapFunc}}{\emph{flag=None}, \emph{RGB=None}, \emph{mpath=None}, \emph{mode=None}, \emph{func=None}, \emph{dsize=None}, \emph{dst=None}, \emph{fx=None}, \emph{fy=None}, \emph{interpolation=None}}{}
\end{fulllineitems}

\index{get\_np2qi() (RRtoolbox.lib.image.ImFactory method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.ImFactory.get_np2qi}\pysiglinewithargsret{\bfcode{get\_np2qi}}{}{}
\end{fulllineitems}

\index{get\_resizeFunc() (RRtoolbox.lib.image.ImFactory method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.ImFactory.get_resizeFunc}\pysiglinewithargsret{\bfcode{get\_resizeFunc}}{\emph{dsize=None}, \emph{dst=None}, \emph{fx=None}, \emph{fy=None}, \emph{interpolation=None}}{}
\end{fulllineitems}

\index{get\_transposeFunc() (RRtoolbox.lib.image.ImFactory method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.ImFactory.get_transposeFunc}\pysiglinewithargsret{\bfcode{get\_transposeFunc}}{}{}
\end{fulllineitems}

\index{update() (RRtoolbox.lib.image.ImFactory method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.ImFactory.update}\pysiglinewithargsret{\bfcode{update}}{\emph{**kwargs}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{ImLoader (class in RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.ImLoader}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.image.}\bfcode{ImLoader}}{\emph{path}, \emph{flag=0}, \emph{dsize=None}, \emph{dst=None}, \emph{fx=None}, \emph{fy=None}, \emph{interpolation=None}, \emph{mmode=None}, \emph{mpath=None}, \emph{throw=True}}{}
Class to load image array from path, url,
server, string or directly from numpy array (supports databases).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{flag}} -- 
(default: 0) 0 to read as gray, 1 to read as BGR, -1 to
read as BGRA, 2 to read as RGB, -2 to read as RGBA.
\begin{description}
\item[{It supports openCV flags:}] \leavevmode\begin{itemize}
\item {} 
cv2.CV\_LOAD\_IMAGE\_COLOR

\item {} 
cv2.CV\_LOAD\_IMAGE\_GRAYSCALE

\item {} 
cv2.CV\_LOAD\_IMAGE\_UNCHANGED

\end{itemize}

\end{description}

\begin{tabular}{|p{0.317\linewidth}|p{0.317\linewidth}|p{0.317\linewidth}|}
\hline
\textsf{\relax 
value
} & \textsf{\relax 
openCV flag
} & \textsf{\relax 
output
}\\
\hline\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
\end{enumerate}
 & 
N/A
 & 
RGB
\\
\hline\begin{enumerate}
\item {} 
\end{enumerate}
 & 
cv2.CV\_LOAD\_IMAGE\_COLOR
 & 
BGR
\\
\hline\begin{enumerate}
\setcounter{enumi}{-1}
\item {} 
\end{enumerate}
 & 
cv2.CV\_LOAD\_IMAGE\_GRAYSCALE
 & 
GRAY
\\
\hline
(-1)
 & 
cv2.CV\_LOAD\_IMAGE\_UNCHANGED
 & 
BGRA
\\
\hline
(-2)
 & 
N/A
 & 
RGBA
\\
\hline\end{tabular}



\item {} 
\textbf{\texttt{dsize}} -- 
(None) output image size; if it equals zero, it is computed as:

exttt\{dsize = Size(round(fx*src.cols), round(fy*src.rows))\}


\item {} 
\textbf{\texttt{dst}} -- (None) output image; it has the size dsize (when it is non-zero) or the
size computed from src.size(), fx, and fy; the type of dst is uint8.

\item {} 
\textbf{\texttt{fx}} -- 
scale factor along the horizontal axis; when it equals 0, it is computed as

exttt\{(double)dsize.width/src.cols\}


\item {} 
\textbf{\texttt{fy}} -- 
scale factor along the vertical axis; when it equals 0, it is computed as

exttt\{(double)dsize.height/src.rows\}


\item {} 
\textbf{\texttt{interpolation}} -- 
interpolation method compliant with opencv:

\begin{tabular}{|p{0.317\linewidth}|p{0.317\linewidth}|p{0.317\linewidth}|}
\hline
\textsf{\relax 
flag
} & \textsf{\relax 
Operation
} & \textsf{\relax 
Description
}\\
\hline\begin{enumerate}
\setcounter{enumi}{-1}
\item {} 
\end{enumerate}
 & 
INTER\_NEAREST
 & 
nearest-neighbor interpolation
\\
\hline\begin{enumerate}
\item {} 
\end{enumerate}
 & 
INTER\_LINEAR
 & 
bilinear interpolation (used by default)
\\
\hline\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
\end{enumerate}
 & 
INTER\_CUBIC
 & 
bicubic interpolation over 4x4 pixel neighborhood
\\
\hline\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
\end{enumerate}
 & 
INTER\_AREA
 & 
resampling using pixel area relation.
It may be a preferred method for image decimation,
as it gives moire-free results. But when the image
is zoomed, it is similar to the INTER\_NEAREST method.
\\
\hline\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
\end{enumerate}
 & 
INTER\_LANCZOS4
 & 
Lanczos interpolation over 8x8 pixel neighborhood
\\
\hline\end{tabular}



\item {} 
\textbf{\texttt{mmode}} -- (None) mmode to create mapped file. if mpath is specified loads image, converts
to mapped file and then loads mapping file with mode \{None, `r+', `r', `w+', `c'\}
(it is slow for big images). If None, loads mapping file to memory (useful to keep
image copy for session even if original image is deleted or modified).

\item {} 
\textbf{\texttt{mpath}} -- (None) path to create mapped file.
None, do not create mapping file
``'', uses path directory;
``*'', uses working directory;
else, uses specified directory.

\end{itemize}

\end{description}\end{quote}

\begin{notice}{note}{Note:}
If mmode is None and mpath is given it creates mmap file but loads from it to memory.
It is useful to create physical copy of data to keep loading from (data can be reloaded
even if original file is moved or deleted).
\end{notice}
\index{getConfiguration() (RRtoolbox.lib.image.ImLoader method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.ImLoader.getConfiguration}\pysiglinewithargsret{\bfcode{getConfiguration}}{\emph{**kwargs}}{}
get Custom configuration from default configuration
:param kwargs: keys to customize default configuration.
\begin{quote}

If no key is provided default configuration is returned.
\end{quote}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
dictionary of configuration

\end{description}\end{quote}

\end{fulllineitems}

\index{temp() (RRtoolbox.lib.image.ImLoader method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.ImLoader.temp}\pysiglinewithargsret{\bfcode{temp}}{\emph{**kwargs}}{}
loads from temporal loader created with customized and default parameters.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{kwargs}} -- keys to customize default configuration.

\item[{Returns}] \leavevmode
loaded image.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Image (class in RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.Image}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.image.}\bfcode{Image}}{\emph{name=None}, \emph{ext=None}, \emph{path=None}, \emph{shape=None}, \emph{verbosity=False}}{}
Bases: \code{object}

Structure to load and save images
\index{BGR (RRtoolbox.lib.image.Image attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.Image.BGR}\pysigline{\bfcode{BGR}}
\end{fulllineitems}

\index{BGRA (RRtoolbox.lib.image.Image attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.Image.BGRA}\pysigline{\bfcode{BGRA}}
\end{fulllineitems}

\index{RGB (RRtoolbox.lib.image.Image attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.Image.RGB}\pysigline{\bfcode{RGB}}
\end{fulllineitems}

\index{RGBA (RRtoolbox.lib.image.Image attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.Image.RGBA}\pysigline{\bfcode{RGBA}}
\end{fulllineitems}

\index{ext (RRtoolbox.lib.image.Image attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.Image.ext}\pysigline{\bfcode{ext}}
\end{fulllineitems}

\index{gray (RRtoolbox.lib.image.Image attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.Image.gray}\pysigline{\bfcode{gray}}
\end{fulllineitems}

\index{load() (RRtoolbox.lib.image.Image method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.Image.load}\pysiglinewithargsret{\bfcode{load}}{\emph{name=None}, \emph{path=None}, \emph{shape=None}}{}
\end{fulllineitems}

\index{path (RRtoolbox.lib.image.Image attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.Image.path}\pysigline{\bfcode{path}}
\end{fulllineitems}

\index{save() (RRtoolbox.lib.image.Image method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.Image.save}\pysiglinewithargsret{\bfcode{save}}{\emph{name=None}, \emph{image=None}, \emph{overwrite=None}}{}
save restored image in path.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{name}} -- filename, string to format or path to save image.
if path is not a string it would be replaced with the string
``\{path\}restored\_\{name\}\{ext\}'' to format with the formatting
``\{path\}'', ``\{name\}'' and ``\{ext\}'' from the baseImage variable.

\item {} 
\textbf{\texttt{image}} -- (self.BGRA)

\item {} 
\textbf{\texttt{overwrite}} -- If True and the destine filename for saving already
exists then it is replaced, else a new filename is generated
with an index ``\{filename\}\_\{index\}.\{extension\}''

\end{itemize}

\item[{Returns}] \leavevmode
saved path, status (True for success and False for fail)

\end{description}\end{quote}

\end{fulllineitems}

\index{shape (RRtoolbox.lib.image.Image attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.Image.shape}\pysigline{\bfcode{shape}}
\end{fulllineitems}


\end{fulllineitems}

\index{LoaderDict (class in RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.LoaderDict}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.image.}\bfcode{LoaderDict}}{\emph{loader=None}, \emph{maxMemory=None}, \emph{margin=0.8}, \emph{unit='MB'}, \emph{all=True}, \emph{config=None}}{}
Bases: {\hyperref[RRtoolbox.lib:RRtoolbox.lib.cache.ResourceManager]{\emph{\code{RRtoolbox.lib.cache.ResourceManager}}}}

Class to standardize loading objects and manage memory efficiently.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{loader}} -- default loader for objects (e.g. load from file or create instance object)

\item {} 
\textbf{\texttt{maxMemory}} -- (None) max memory in specified unit to keep in check optimization (it does
not mean that memory never surpasses maxMemory).

\item {} 
\textbf{\texttt{margin}} -- (0.8) margin from maxMemory to trigger optimization.
It is in percentage of maxMemory ranging from 0 (0\%) to maximum 1 (100\%).
So optimal memory is inside range: maxMemory*margin \textless{} Memory \textless{} maxMemory

\item {} 
\textbf{\texttt{unit}} -- (MB) maxMemory unit, it can be GB (Gigabytes), MB (Megabytes), B (bytes)

\item {} 
\textbf{\texttt{all}} -- if True used memory is from all alive references,
if False used memory is only from keptAlive references.

\item {} 
\textbf{\texttt{config}} -- (Not Implemented)

\end{itemize}

\end{description}\end{quote}
\index{register() (RRtoolbox.lib.image.LoaderDict method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.LoaderDict.register}\pysiglinewithargsret{\bfcode{register}}{\emph{key}, \emph{path=None}, \emph{method=None}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{PathLoader (class in RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.PathLoader}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.image.}\bfcode{PathLoader}}{\emph{fns=None}, \emph{loader=None}}{}
Bases: \code{\_abcoll.MutableSequence}

Class to standardize loading images from list of paths and offer lazy evaluations.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{fns}} -- list of paths

\item {} 
\textbf{\texttt{loader}} -- path loader (loadcv,loadsfrom, or function from loadFunc)

\end{itemize}

\end{description}\end{quote}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{fns} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{/path to/image 1.ext}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{/path to/image 2.ext}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{n}{imgs} \PYG{o}{=} \PYG{n}{pathLoader}\PYG{p}{(}\PYG{n}{fns}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{imgs}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} loads image in path 0}
\PYG{k}{print} \PYG{n}{imgs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} loads image in path 1}
\end{Verbatim}
\index{insert() (RRtoolbox.lib.image.PathLoader method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.PathLoader.insert}\pysiglinewithargsret{\bfcode{insert}}{\emph{index}, \emph{value}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{bgra2bgr() (in module RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.bgra2bgr}\pysiglinewithargsret{\code{RRtoolbox.lib.image.}\bfcode{bgra2bgr}}{\emph{im}, \emph{bgrcolor=(255}, \emph{255}, \emph{255)}}{}
Convert BGR to BGRA image.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{im}} -- image

\item {} 
\textbf{\texttt{bgrcolor}} -- BGR color representing transparency. (information is lost when
converting BGRA to BGR) e.g. {[}200,200,200{]}.

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{checkLoaded() (in module RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.checkLoaded}\pysiglinewithargsret{\code{RRtoolbox.lib.image.}\bfcode{checkLoaded}}{\emph{obj}, \emph{fn='`}, \emph{raiseError=False}}{}
Simple function to determine if variable is valid.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{obj}} -- loaded object

\item {} 
\textbf{\texttt{fn}} -- path of file

\item {} 
\textbf{\texttt{raiseError}} -- if True and obj is None, raise

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{convertAs() (in module RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.convertAs}\pysiglinewithargsret{\code{RRtoolbox.lib.image.}\bfcode{convertAs}}{\emph{fns}, \emph{base=None}, \emph{folder=None}, \emph{name=None}, \emph{ext=None}, \emph{overwrite=False}, \emph{loader=None}, \emph{simulate=False}}{}
Reads a file and save as other file based in a pattern.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{fns}} -- file name or list of file names. It supports glob operations.
By default glob operations ignore folders.

\item {} 
\textbf{\texttt{base}} -- path to place images.

\item {} 
\textbf{\texttt{folder}} -- (None) folder to place images in base's path.
If True it uses the folder in which image was loaded.
If None, not folder is used.

\item {} 
\textbf{\texttt{name}} -- string for formatting new name of image with the \{name\} tag.
Ex: if name is `new\_\{name\}' and image is called `img001' then the
formatted new image's name is `new\_img001'

\item {} 
\textbf{\texttt{ext}} -- (None) extension to save all images. If None uses the same extension
as the loaded image.

\item {} 
\textbf{\texttt{overwrite}} -- (False) If True and the destine filename for saving already
exists then it is replaced, else a new filename is generated
with an index ``\{name\}\_\{index\}.\{extension\}''

\item {} 
\textbf{\texttt{loader}} -- (None) loader for the image file to change image attributes.
If None reads the original images untouched.

\item {} 
\textbf{\texttt{simulate}} -- (False) if True, no saving is performed but the status is returned
to confirm what images where adequately processed.

\end{itemize}

\item[{Returns}] \leavevmode
list of statuses (0 - no error, 1 - image not loaded,
2 - image not saved, 3 - error in processing image)

\end{description}\end{quote}

\end{fulllineitems}

\index{drawcoorarea() (in module RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.drawcoorarea}\pysiglinewithargsret{\code{RRtoolbox.lib.image.}\bfcode{drawcoorarea}}{\emph{vis}, \emph{points}, \emph{col\_out=(0}, \emph{0}, \emph{0)}, \emph{col\_in=(0}, \emph{0}, \emph{255)}, \emph{radius=2}}{}
Function to draw interaction with points to obtain area.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{vis}} -- image array.

\item {} 
\textbf{\texttt{points}} -- list of points.

\item {} 
\textbf{\texttt{col\_out}} -- outer color of point.

\item {} 
\textbf{\texttt{col\_in}} -- inner color of point.

\item {} 
\textbf{\texttt{radius}} -- radius of drawn points.

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{drawcooraxes() (in module RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.drawcooraxes}\pysiglinewithargsret{\code{RRtoolbox.lib.image.}\bfcode{drawcooraxes}}{\emph{vis}, \emph{points}, \emph{col\_out=(0}, \emph{0}, \emph{0)}, \emph{col\_in=(0}, \emph{255}, \emph{0)}, \emph{radius=2}}{}
Function to draw axes instead of points.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{vis}} -- image array.

\item {} 
\textbf{\texttt{points}} -- list of points.

\item {} 
\textbf{\texttt{col\_out}} -- outer color of point.

\item {} 
\textbf{\texttt{col\_in}} -- inner color of point.

\item {} 
\textbf{\texttt{radius}} -- radius of drawn points.

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{drawcoorperspective() (in module RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.drawcoorperspective}\pysiglinewithargsret{\code{RRtoolbox.lib.image.}\bfcode{drawcoorperspective}}{\emph{vis}, \emph{points}, \emph{col\_out=(0}, \emph{0}, \emph{0)}, \emph{col\_in=(0}, \emph{0}, \emph{255)}, \emph{radius=2}}{}
Function to draw interaction with points to obtain perspective.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{vis}} -- image array.

\item {} 
\textbf{\texttt{points}} -- list of points.

\item {} 
\textbf{\texttt{col\_out}} -- outer color of point.

\item {} 
\textbf{\texttt{col\_in}} -- inner color of point.

\item {} 
\textbf{\texttt{radius}} -- radius of drawn points.

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{drawcoorpoints() (in module RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.drawcoorpoints}\pysiglinewithargsret{\code{RRtoolbox.lib.image.}\bfcode{drawcoorpoints}}{\emph{vis}, \emph{points}, \emph{col\_out=(0}, \emph{0}, \emph{0)}, \emph{col\_in=(0}, \emph{0}, \emph{255)}, \emph{radius=2}}{}
Funtion to draw points.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{vis}} -- image array.

\item {} 
\textbf{\texttt{points}} -- list of points.

\item {} 
\textbf{\texttt{col\_out}} -- outer color of point.

\item {} 
\textbf{\texttt{col\_in}} -- inner color of point.

\item {} 
\textbf{\texttt{radius}} -- radius of drawn points.

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{drawcoorpolyArrow() (in module RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.drawcoorpolyArrow}\pysiglinewithargsret{\code{RRtoolbox.lib.image.}\bfcode{drawcoorpolyArrow}}{\emph{vis}, \emph{points}, \emph{col\_out=(0}, \emph{0}, \emph{0)}, \emph{col\_in=(0}, \emph{0}, \emph{255)}, \emph{radius=2}}{}
Function to draw interaction with vectors to obtain polygonal.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{vis}} -- image array.

\item {} 
\textbf{\texttt{points}} -- list of points.

\item {} 
\textbf{\texttt{col\_out}} -- outer color of point.

\item {} 
\textbf{\texttt{col\_in}} -- inner color of point.

\item {} 
\textbf{\texttt{radius}} -- radius of drawn points.

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{drawcoorpolyline() (in module RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.drawcoorpolyline}\pysiglinewithargsret{\code{RRtoolbox.lib.image.}\bfcode{drawcoorpolyline}}{\emph{vis}, \emph{points}, \emph{col\_out=(0}, \emph{0}, \emph{0)}, \emph{col\_in=(0}, \emph{0}, \emph{255)}, \emph{radius=2}}{}
Function to draw interaction with points to obtain polygonal.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{vis}} -- image array.

\item {} 
\textbf{\texttt{points}} -- list of points.

\item {} 
\textbf{\texttt{col\_out}} -- outer color of point.

\item {} 
\textbf{\texttt{col\_in}} -- inner color of point.

\item {} 
\textbf{\texttt{radius}} -- radius of drawn points.

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{fig2bgr() (in module RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.fig2bgr}\pysiglinewithargsret{\code{RRtoolbox.lib.image.}\bfcode{fig2bgr}}{\emph{fig}}{}
Convert a Matplotlib figure to a RGB image.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{fig}} -- a matplotlib figure

\item[{Returns}] \leavevmode
RGB image.

\end{description}\end{quote}

\end{fulllineitems}

\index{fig2bgra() (in module RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.fig2bgra}\pysiglinewithargsret{\code{RRtoolbox.lib.image.}\bfcode{fig2bgra}}{\emph{fig}}{}
Convert a Matplotlib figure to a RGBA image.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{fig}} -- a matplotlib figure

\item[{Returns}] \leavevmode
RGBA image.

\end{description}\end{quote}

\end{fulllineitems}

\index{getcoors() (in module RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.getcoors}\pysiglinewithargsret{\code{RRtoolbox.lib.image.}\bfcode{getcoors}}{\emph{im}, \emph{win='get coordinates'}, \emph{updatefunc=\textless{}function drawcoorpoints\textgreater{}}, \emph{coors=None}, \emph{prox=8}, \emph{radius=3}, \emph{unique=True}, \emph{col\_out=(0}, \emph{0}, \emph{0)}, \emph{col\_in=(0}, \emph{0}, \emph{255)}}{}
\end{fulllineitems}

\index{getgeometrycoors() (in module RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.getgeometrycoors}\pysiglinewithargsret{\code{RRtoolbox.lib.image.}\bfcode{getgeometrycoors}}{\emph{*data}}{}
Get filled object coordinates. (function in progress)

\end{fulllineitems}

\index{getrectcoors() (in module RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.getrectcoors}\pysiglinewithargsret{\code{RRtoolbox.lib.image.}\bfcode{getrectcoors}}{\emph{*data}}{}~\begin{quote}

Get ordered points.
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{data}} -- list of points

\item[{Returns}] \leavevmode
{[}Top\_left,Top\_right,Bottom\_left,Bottom\_right{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{gray2qi() (in module RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.gray2qi}\pysiglinewithargsret{\code{RRtoolbox.lib.image.}\bfcode{gray2qi}}{\emph{gray}}{}
Convert the 2D numpy array \emph{gray} into a 8-bit QImage with a gray
colormap.  The first dimension represents the vertical image axis.

ATTENTION: This QImage carries an attribute \emph{ndimage} with a
reference to the underlying numpy array that holds the data. On
Windows, the conversion into a QPixmap does not copy the data, so
that you have to take care that the QImage does not get garbage
collected (otherwise PyQt will throw away the wrapper, effectively
freeing the underlying memory - boom!).

source from: \href{https://kogs-www.informatik.uni-hamburg.de/~meine/software/vigraqt/qimage2ndarray.py}{https://kogs-www.informatik.uni-hamburg.de/\textasciitilde{}meine/software/vigraqt/qimage2ndarray.py}

\end{fulllineitems}

\index{hist\_match() (in module RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.hist_match}\pysiglinewithargsret{\code{RRtoolbox.lib.image.}\bfcode{hist\_match}}{\emph{source}, \emph{template}, \emph{alpha=None}}{}
Adjust the pixel values of an image to match those of a template image.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{source}} -- image to transform colors to template

\item {} 
\textbf{\texttt{template}} -- template image ()

\item {} 
\textbf{\texttt{alpha}} -- 

\end{itemize}

\item[{Returns}] \leavevmode
transformed source

\end{description}\end{quote}

\end{fulllineitems}

\index{interpretImage() (in module RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.interpretImage}\pysiglinewithargsret{\code{RRtoolbox.lib.image.}\bfcode{interpretImage}}{\emph{toparse}, \emph{flags}}{}
Interprets to get image.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{toparse}} -- 
string to parse or array. It can interpret:

{\color{red}\bfseries{}*}connection to server (i.e. host:port)
{\color{red}\bfseries{}*}path to file (e.g. /path\_to\_image/image\_name.ext)
{\color{red}\bfseries{}*}URL to image (e.g. \href{http://domain.com/path\_to\_image/image\_name.ext}{http://domain.com/path\_to\_image/image\_name.ext})
{\color{red}\bfseries{}*}image as string (i.g. numpy converted to string)
{\color{red}\bfseries{}*}image itself (i.e. numpy array)


\item {} 
\textbf{\texttt{flags}} -- 
openCV flags:

\begin{tabular}{|p{0.317\linewidth}|p{0.317\linewidth}|p{0.317\linewidth}|}
\hline
\textsf{\relax 
value
} & \textsf{\relax 
openCV flag
} & \textsf{\relax 
output
}\\
\hline\begin{enumerate}
\item {} 
\end{enumerate}
 & 
cv2.CV\_LOAD\_IMAGE\_COLOR
 & 
BGR
\\
\hline\begin{enumerate}
\setcounter{enumi}{-1}
\item {} 
\end{enumerate}
 & 
cv2.CV\_LOAD\_IMAGE\_GRAYSCALE
 & 
GRAY
\\
\hline
(-1)
 & 
cv2.CV\_LOAD\_IMAGE\_UNCHANGED
 & 
format
\\
\hline\end{tabular}



\end{itemize}

\item[{Returns}] \leavevmode
image or None if not successfull

\end{description}\end{quote}

\end{fulllineitems}

\index{limitaxispoints() (in module RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.limitaxispoints}\pysiglinewithargsret{\code{RRtoolbox.lib.image.}\bfcode{limitaxispoints}}{\emph{c}, \emph{maxc}, \emph{minc=0}}{}
Limit a point in axis.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{c}} -- list of points..

\item {} 
\textbf{\texttt{maxc}} -- maximum value of point.

\item {} 
\textbf{\texttt{minc}} -- minimum value of point.

\end{itemize}

\item[{Returns}] \leavevmode
return limited points.

\end{description}\end{quote}

\end{fulllineitems}

\index{loadFunc() (in module RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.loadFunc}\pysiglinewithargsret{\code{RRtoolbox.lib.image.}\bfcode{loadFunc}}{\emph{flag=0}, \emph{dsize=None}, \emph{dst=None}, \emph{fx=None}, \emph{fy=None}, \emph{interpolation=None}, \emph{mmode=None}, \emph{mpath=None}, \emph{throw=True}, \emph{keepratio=True}}{}
Creates a function that loads image array from path, url,
server, string or directly from numpy array (supports databases).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{flag}} -- 
(default: 0) 0 to read as gray, 1 to read as BGR, -1 to
read as BGRA, 2 to read as RGB, -2 to read as RGBA.
\begin{description}
\item[{It supports openCV flags:}] \leavevmode\begin{itemize}
\item {} 
cv2.CV\_LOAD\_IMAGE\_COLOR

\item {} 
cv2.CV\_LOAD\_IMAGE\_GRAYSCALE

\item {} 
cv2.CV\_LOAD\_IMAGE\_UNCHANGED

\end{itemize}

\end{description}

\begin{tabular}{|p{0.317\linewidth}|p{0.317\linewidth}|p{0.317\linewidth}|}
\hline
\textsf{\relax 
value
} & \textsf{\relax 
openCV flag
} & \textsf{\relax 
output
}\\
\hline\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
\end{enumerate}
 & 
N/A
 & 
RGB
\\
\hline\begin{enumerate}
\item {} 
\end{enumerate}
 & 
cv2.CV\_LOAD\_IMAGE\_COLOR
 & 
BGR
\\
\hline\begin{enumerate}
\setcounter{enumi}{-1}
\item {} 
\end{enumerate}
 & 
cv2.CV\_LOAD\_IMAGE\_GRAYSCALE
 & 
GRAY
\\
\hline
(-1)
 & 
cv2.CV\_LOAD\_IMAGE\_UNCHANGED
 & 
BGRA
\\
\hline
(-2)
 & 
N/A
 & 
RGBA
\\
\hline\end{tabular}



\item {} 
\textbf{\texttt{dsize}} -- 
(None) output image size; if it equals zero, it is computed as:
\begin{quote}

exttt\{dsize = Size(round(fx*src.cols), round(fy*src.rows))\}
\end{quote}

If (integer,None) or (None,integer) it completes the values according
to keepratio parameter.


\item {} 
\textbf{\texttt{dst}} -- (None) output image; it has the size dsize (when it is non-zero) or the
size computed from src.size(), fx, and fy; the type of dst is uint8.

\item {} 
\textbf{\texttt{fx}} -- scale factor along the horizontal axis

\item {} 
\textbf{\texttt{fy}} -- scale factor along the vertical axis

\item {} 
\textbf{\texttt{interpolation}} -- 
interpolation method compliant with opencv:

\begin{tabular}{|p{0.317\linewidth}|p{0.317\linewidth}|p{0.317\linewidth}|}
\hline
\textsf{\relax 
flag
} & \textsf{\relax 
Operation
} & \textsf{\relax 
Description
}\\
\hline\begin{enumerate}
\setcounter{enumi}{-1}
\item {} 
\end{enumerate}
 & 
INTER\_NEAREST
 & 
nearest-neighbor interpolation
\\
\hline\begin{enumerate}
\item {} 
\end{enumerate}
 & 
INTER\_LINEAR
 & 
bilinear interpolation (used by default)
\\
\hline\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
\end{enumerate}
 & 
INTER\_CUBIC
 & 
bicubic interpolation over 4x4 pixel neighborhood
\\
\hline\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
\end{enumerate}
 & 
INTER\_AREA
 & 
resampling using pixel area relation.
It may be a preferred method for image decimation,
as it gives moire-free results. But when the image
is zoomed, it is similar to the INTER\_NEAREST method.
\\
\hline\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
\end{enumerate}
 & 
INTER\_LANCZOS4
 & 
Lanczos interpolation over 8x8 pixel neighborhood
\\
\hline\end{tabular}



\item {} 
\textbf{\texttt{mmode}} -- (None) mmode to create mapped file. if mpath is specified loads image, converts
to mapped file and then loads mapping file with mode \{None, `r+', `r', `w+', `c'\}
(it is slow for big images). If None, loads mapping file to memory (useful to keep
image copy for session even if original image is deleted or modified).

\item {} 
\textbf{\texttt{mpath}} -- (None) path to create mapped file.
None, do not create mapping file
``'', uses path directory;
``*'', uses working directory;
else, uses specified directory.

\item {} 
\textbf{\texttt{keepratio}} -- True to keep image ratio when completing data from dsize,fx and fy,
False to not keep ratio.

\end{itemize}

\end{description}\end{quote}

\begin{notice}{note}{Note:}
If mmode is None and mpath is given it creates mmap file but loads from it to memory.
It is useful to create physical copy of data to keep loading from (data can be reloaded
even if original file is moved or deleted).
\end{notice}

:return loader function

\end{fulllineitems}

\index{loadcv() (in module RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.loadcv}\pysiglinewithargsret{\code{RRtoolbox.lib.image.}\bfcode{loadcv}}{\emph{path}, \emph{flags=-1}, \emph{shape=None}}{}
Simple function to load using opencv.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{path}} -- path to image.

\item {} 
\textbf{\texttt{flag}} -- 
openCV flags:

\begin{tabular}{|p{0.317\linewidth}|p{0.317\linewidth}|p{0.317\linewidth}|}
\hline
\textsf{\relax 
value
} & \textsf{\relax 
openCV flag
} & \textsf{\relax 
output
}\\
\hline\begin{enumerate}
\item {} 
\end{enumerate}
 & 
cv2.CV\_LOAD\_IMAGE\_COLOR
 & 
BGR
\\
\hline\begin{enumerate}
\setcounter{enumi}{-1}
\item {} 
\end{enumerate}
 & 
cv2.CV\_LOAD\_IMAGE\_GRAYSCALE
 & 
GRAY
\\
\hline
(-1)
 & 
cv2.CV\_LOAD\_IMAGE\_UNCHANGED
 & 
format
\\
\hline\end{tabular}



\item {} 
\textbf{\texttt{shape}} -- shape to resize image.

\end{itemize}

\item[{Returns}] \leavevmode
loaded image

\end{description}\end{quote}

\end{fulllineitems}

\index{loadsfrom() (in module RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.loadsfrom}\pysiglinewithargsret{\code{RRtoolbox.lib.image.}\bfcode{loadsfrom}}{\emph{path}, \emph{flags=1L}}{}
Loads Image from URL or file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{path}} -- filepath or url

\item {} 
\textbf{\texttt{flags}} -- 
openCV flags:

\begin{tabular}{|p{0.317\linewidth}|p{0.317\linewidth}|p{0.317\linewidth}|}
\hline
\textsf{\relax 
value
} & \textsf{\relax 
openCV flag
} & \textsf{\relax 
output
}\\
\hline\begin{enumerate}
\item {} 
\end{enumerate}
 & 
cv2.CV\_LOAD\_IMAGE\_COLOR
 & 
BGR
\\
\hline\begin{enumerate}
\setcounter{enumi}{-1}
\item {} 
\end{enumerate}
 & 
cv2.CV\_LOAD\_IMAGE\_GRAYSCALE
 & 
GRAY
\\
\hline
(-1)
 & 
cv2.CV\_LOAD\_IMAGE\_UNCHANGED
 & 
format
\\
\hline\end{tabular}



\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{myline() (in module RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.myline}\pysiglinewithargsret{\code{RRtoolbox.lib.image.}\bfcode{myline}}{\emph{img}, \emph{pt1}, \emph{pt2}, \emph{color}, \emph{thickness=None}}{}
Funtion to draw points (experimental).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{img}} -- 

\item {} 
\textbf{\texttt{pt1}} -- 

\item {} 
\textbf{\texttt{pt2}} -- 

\item {} 
\textbf{\texttt{color}} -- 

\item {} 
\textbf{\texttt{thickness}} -- 

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{np2qi() (in module RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.np2qi}\pysiglinewithargsret{\code{RRtoolbox.lib.image.}\bfcode{np2qi}}{\emph{array}}{}
Convert numpy array to Qt Image.

source from: \href{https://kogs-www.informatik.uni-hamburg.de/~meine/software/vigraqt/qimage2ndarray.py}{https://kogs-www.informatik.uni-hamburg.de/\textasciitilde{}meine/software/vigraqt/qimage2ndarray.py}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{array}} -- 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{np2str() (in module RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.np2str}\pysiglinewithargsret{\code{RRtoolbox.lib.image.}\bfcode{np2str}}{\emph{arr}}{}
\end{fulllineitems}

\index{plt2bgr() (in module RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.plt2bgr}\pysiglinewithargsret{\code{RRtoolbox.lib.image.}\bfcode{plt2bgr}}{\emph{image}}{}
\end{fulllineitems}

\index{plt2bgra() (in module RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.plt2bgra}\pysiglinewithargsret{\code{RRtoolbox.lib.image.}\bfcode{plt2bgra}}{\emph{image}}{}
\end{fulllineitems}

\index{qi2np() (in module RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.qi2np}\pysiglinewithargsret{\code{RRtoolbox.lib.image.}\bfcode{qi2np}}{\emph{qimage}, \emph{dtype='array'}}{}
Convert QImage to numpy.ndarray.  The dtype defaults to uint8
for QImage.Format\_Indexed8 or \emph{bgra\_dtype} (i.e. a record array)
for 32bit color images.  You can pass a different dtype to use, or
`array' to get a 3D uint8 array for color images.

source from: \href{https://kogs-www.informatik.uni-hamburg.de/~meine/software/vigraqt/qimage2ndarray.py}{https://kogs-www.informatik.uni-hamburg.de/\textasciitilde{}meine/software/vigraqt/qimage2ndarray.py}

\end{fulllineitems}

\index{quadrants() (in module RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.quadrants}\pysiglinewithargsret{\code{RRtoolbox.lib.image.}\bfcode{quadrants}}{\emph{points}}{}
Separate points respect to center of gravity point.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{points}} -- list of points

\item[{Returns}] \leavevmode
{[}{[}Top\_left{]},{[}Top\_right{]},{[}Bottom\_left{]},{[}Bottom\_right{]}{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{random\_color() (in module RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.random_color}\pysiglinewithargsret{\code{RRtoolbox.lib.image.}\bfcode{random\_color}}{\emph{channels=1}, \emph{min=0}, \emph{max=256}}{}
Random color.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{channels}} -- number of channels

\item {} 
\textbf{\texttt{min}} -- min color in any channel

\item {} 
\textbf{\texttt{max}} -- max color in any channel

\end{itemize}

\item[{Returns}] \leavevmode
random color

\end{description}\end{quote}

\end{fulllineitems}

\index{rgb2qi() (in module RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.rgb2qi}\pysiglinewithargsret{\code{RRtoolbox.lib.image.}\bfcode{rgb2qi}}{\emph{rgb}}{}
Convert the 3D numpy array \emph{rgb} into a 32-bit QImage.  \emph{rgb} must
have three dimensions with the vertical, horizontal and RGB image axes.

ATTENTION: This QImage carries an attribute \emph{ndimage} with a
reference to the underlying numpy array that holds the data. On
Windows, the conversion into a QPixmap does not copy the data, so
that you have to take care that the QImage does not get garbage
collected (otherwise PyQt will throw away the wrapper, effectively
freeing the underlying memory - boom!).

source from: \href{https://kogs-www.informatik.uni-hamburg.de/~meine/software/vigraqt/qimage2ndarray.py}{https://kogs-www.informatik.uni-hamburg.de/\textasciitilde{}meine/software/vigraqt/qimage2ndarray.py}

\end{fulllineitems}

\index{separe() (in module RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.separe}\pysiglinewithargsret{\code{RRtoolbox.lib.image.}\bfcode{separe}}{\emph{values}, \emph{sep}, \emph{axis=0}}{}
Separate values from separator or threshold.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{values}} -- list of values

\item {} 
\textbf{\texttt{sep}} -- peparator value

\item {} 
\textbf{\texttt{axis}} -- axis in each value

\end{itemize}

\end{description}\end{quote}

:return:lists of greater values, list of lesser values

\end{fulllineitems}

\index{str2np() (in module RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.str2np}\pysiglinewithargsret{\code{RRtoolbox.lib.image.}\bfcode{str2np}}{\emph{string}, \emph{shape}}{}
\end{fulllineitems}

\index{transposeIm() (in module RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.transposeIm}\pysiglinewithargsret{\code{RRtoolbox.lib.image.}\bfcode{transposeIm}}{\emph{im}}{}
\end{fulllineitems}

\index{try\_loads() (in module RRtoolbox.lib.image)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.image.try_loads}\pysiglinewithargsret{\code{RRtoolbox.lib.image.}\bfcode{try\_loads}}{\emph{fns}, \emph{func=\textless{}built-in function imread\textgreater{}}, \emph{paths=None}, \emph{debug=False}, \emph{addpath=False}}{}
Try to load images from paths.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{fns}} -- list of file names

\item {} 
\textbf{\texttt{func}} -- loader function

\item {} 
\textbf{\texttt{paths}} -- paths to try. By default it loads working dir and test path

\item {} 
\textbf{\texttt{debug}} -- True to show debug messages

\item {} 
\textbf{\texttt{addpath}} -- add path as second argument

\end{itemize}

\item[{Returns}] \leavevmode
image else None

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{RRtoolbox.lib.inspector module}
\label{RRtoolbox.lib:module-RRtoolbox.lib.inspector}\label{RRtoolbox.lib:rrtoolbox-lib-inspector-module}\index{RRtoolbox.lib.inspector (module)}
This module is an all purpose intended for debugging, tracking, auto-documenting and self-introspecting the
package

Made by Davtoh. Powered partially by pycallgraph.
Dependent project: \href{https://github.com/gak/pycallgraph/\#python-call-graph}{https://github.com/gak/pycallgraph/\#python-call-graph}
\index{Asyncronous (class in RRtoolbox.lib.inspector)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.Asyncronous}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.inspector.}\bfcode{Asyncronous}}{\emph{outputs}, \emph{config}}{}
Bases: {\hyperref[RRtoolbox.lib:RRtoolbox.lib.inspector.Syncronous]{\emph{\code{RRtoolbox.lib.inspector.Syncronous}}}}
\index{done() (RRtoolbox.lib.inspector.Asyncronous method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.Asyncronous.done}\pysiglinewithargsret{\bfcode{done}}{}{}
\end{fulllineitems}

\index{start() (RRtoolbox.lib.inspector.Asyncronous method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.Asyncronous.start}\pysiglinewithargsret{\bfcode{start}}{}{}
\end{fulllineitems}

\index{tracer() (RRtoolbox.lib.inspector.Asyncronous method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.Asyncronous.tracer}\pysiglinewithargsret{\bfcode{tracer}}{\emph{frame}, \emph{event}, \emph{arg}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{GraphTrace (class in RRtoolbox.lib.inspector)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.GraphTrace}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.inspector.}\bfcode{GraphTrace}}{\emph{output=None}, \emph{config=None}}{}
Bases: \code{pycallgraph.pycallgraph.PyCallGraph}
\index{get\_tracer\_class() (RRtoolbox.lib.inspector.GraphTrace method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.GraphTrace.get_tracer_class}\pysiglinewithargsret{\bfcode{get\_tracer\_class}}{}{}
\end{fulllineitems}

\index{saveSource() (RRtoolbox.lib.inspector.GraphTrace method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.GraphTrace.saveSource}\pysiglinewithargsret{\bfcode{saveSource}}{\emph{file}}{}
\end{fulllineitems}

\index{source (RRtoolbox.lib.inspector.GraphTrace attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.GraphTrace.source}\pysigline{\bfcode{source}}
\end{fulllineitems}


\end{fulllineitems}

\index{GraphTraceOutput (class in RRtoolbox.lib.inspector)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.GraphTraceOutput}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.inspector.}\bfcode{GraphTraceOutput}}{\emph{source=None}, \emph{saveflag=True}, \emph{label='`}, \emph{**kwargs}}{}
Bases: \code{pycallgraph.output.graphviz.GraphvizOutput}
\index{done() (RRtoolbox.lib.inspector.GraphTraceOutput method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.GraphTraceOutput.done}\pysiglinewithargsret{\bfcode{done}}{}{}
\end{fulllineitems}

\index{save() (RRtoolbox.lib.inspector.GraphTraceOutput method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.GraphTraceOutput.save}\pysiglinewithargsret{\bfcode{save}}{\emph{file=None}, \emph{source=None}}{}
\end{fulllineitems}

\index{saveSource() (RRtoolbox.lib.inspector.GraphTraceOutput method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.GraphTraceOutput.saveSource}\pysiglinewithargsret{\bfcode{saveSource}}{\emph{file}, \emph{source=None}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{Logger (class in RRtoolbox.lib.inspector)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.Logger}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.inspector.}\bfcode{Logger}}{\emph{**kwargs}}{}
Bases: \code{object}

Logger for decorated functions. Holds important information of an instanced object and
can be used with @trace decorator for traceback purposes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{func}} -- object reference.

\item {} 
\textbf{\texttt{funcname}} -- object name.

\item {} 
\textbf{\texttt{inputs}} -- inputs pass to the object.

\item {} 
\textbf{\texttt{outputs}} -- outputs given by the object execution.

\item {} 
\textbf{\texttt{time}} -- initial time of execution.

\item {} 
\textbf{\texttt{exectime}} -- time of execution in seconds.

\item {} 
\textbf{\texttt{writer}} -- writer function where messages are passed.

\item {} 
\textbf{\texttt{eventHandle}} -- event function where object is
passed when Logger.broadcast() is called.

\item {} 
\textbf{\texttt{msg\_report}} -- message format to use in reports.

\item {} 
\textbf{\texttt{msg\_no\_executed}} -- massage format to pass to writer when object
has not been executed and Logger.report() is called.

\item {} 
\textbf{\texttt{msg\_executed}} -- massage format to use when object is
executed and Logger.broadcast() is called.

\end{itemize}

\end{description}\end{quote}
\index{Time\_ (RRtoolbox.lib.inspector.Logger attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.Logger.Time_}\pysigline{\bfcode{Time\_}}
returns formated time (str)

\end{fulllineitems}

\index{Type\_ (RRtoolbox.lib.inspector.Logger attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.Logger.Type_}\pysigline{\bfcode{Type\_}}
returns type name (str)

\end{fulllineitems}

\index{broadcast() (RRtoolbox.lib.inspector.Logger method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.Logger.broadcast}\pysiglinewithargsret{\bfcode{broadcast}}{}{}
pass a notification message on object execution to the writer

\end{fulllineitems}

\index{eventHandle (RRtoolbox.lib.inspector.Logger attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.Logger.eventHandle}\pysigline{\bfcode{eventHandle}\strong{ = None}}
\end{fulllineitems}

\index{file (RRtoolbox.lib.inspector.Logger attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.Logger.file}\pysigline{\bfcode{file}\strong{ = \textless{}open file `\textless{}stdout\textgreater{}', mode `w'\textgreater{}}}
\end{fulllineitems}

\index{renew() (RRtoolbox.lib.inspector.Logger method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.Logger.renew}\pysiglinewithargsret{\bfcode{renew}}{}{}
renew Instance

\end{fulllineitems}

\index{report() (RRtoolbox.lib.inspector.Logger method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.Logger.report}\pysiglinewithargsret{\bfcode{report}}{}{}
pass a report of the last executed object to the writer

\end{fulllineitems}

\index{throwError() (RRtoolbox.lib.inspector.Logger method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.Logger.throwError}\pysiglinewithargsret{\bfcode{throwError}}{}{}
throw caught error
:return:

\end{fulllineitems}

\index{tracer (RRtoolbox.lib.inspector.Logger attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.Logger.tracer}\pysigline{\bfcode{tracer}}
\end{fulllineitems}

\index{writer() (RRtoolbox.lib.inspector.Logger method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.Logger.writer}\pysiglinewithargsret{\bfcode{writer}}{\emph{sender}, \emph{*arg}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{Syncronous (class in RRtoolbox.lib.inspector)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.Syncronous}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.inspector.}\bfcode{Syncronous}}{\emph{outputs}, \emph{config}}{}
Bases: \code{pycallgraph.tracer.SyncronousTracer}
\index{start() (RRtoolbox.lib.inspector.Syncronous method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.Syncronous.start}\pysiglinewithargsret{\bfcode{start}}{}{}
\end{fulllineitems}

\index{stop() (RRtoolbox.lib.inspector.Syncronous method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.Syncronous.stop}\pysiglinewithargsret{\bfcode{stop}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{funcData() (in module RRtoolbox.lib.inspector)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.funcData}\pysiglinewithargsret{\code{RRtoolbox.lib.inspector.}\bfcode{funcData}}{\emph{func}}{}
\end{fulllineitems}

\index{load() (in module RRtoolbox.lib.inspector)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.load}\pysiglinewithargsret{\code{RRtoolbox.lib.inspector.}\bfcode{load}}{\emph{mod\_name}, \emph{obj\_name}}{}
Convert a string version of a class name to the object.

For example, get\_class(`sympy.core.Basic') will return
class Basic located in module sympy.core

\end{fulllineitems}

\index{reloadFunc() (in module RRtoolbox.lib.inspector)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.reloadFunc}\pysiglinewithargsret{\code{RRtoolbox.lib.inspector.}\bfcode{reloadFunc}}{\emph{func}}{}
\end{fulllineitems}

\index{tracer() (in module RRtoolbox.lib.inspector)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.tracer}\pysiglinewithargsret{\code{RRtoolbox.lib.inspector.}\bfcode{tracer}}{\emph{instance}, \emph{broadcast=True}, \emph{report=True}}{}
Tracer for decorated functions.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{instance}} -- Logger instance

\item {} 
\textbf{\texttt{broadcast}} -- 

\item {} 
\textbf{\texttt{report}} -- 

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{RRtoolbox.lib.plotter module}
\label{RRtoolbox.lib:module-RRtoolbox.lib.plotter}\label{RRtoolbox.lib:rrtoolbox-lib-plotter-module}\index{RRtoolbox.lib.plotter (module)}
This module holds the plotting and data-visualization tools. Motto: don't know how it is interpreted? i'll show you!

\#Plotim example
filename = ``t2.jpg''
win = ``test''
img = cv2.resize(cv2.imread(filename), (400, 400))  \# (height, width)
plot = Plotim(win,img)
plot.show()
\index{Edger (class in RRtoolbox.lib.plotter)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Edger}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.plotter.}\bfcode{Edger}}{\emph{img}, \emph{isSIZE=True}, \emph{isEQUA=False}, \emph{isCLAHE=False}, \emph{isBFILTER=False}}{}
Bases: {\hyperref[RRtoolbox.lib:RRtoolbox.lib.plotter.Plotim]{\emph{\code{RRtoolbox.lib.plotter.Plotim}}}}

Test visualization for edges

self.edge -\textgreater{} the edges in processed image
self.img -\textgreater{} the processed image
self.sample -\textgreater{} the rendered precessed image
\index{computeAll() (RRtoolbox.lib.plotter.Edger method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Edger.computeAll}\pysiglinewithargsret{\bfcode{computeAll}}{}{}
\end{fulllineitems}

\index{computeEdge() (RRtoolbox.lib.plotter.Edger method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Edger.computeEdge}\pysiglinewithargsret{\bfcode{computeEdge}}{}{}
\end{fulllineitems}

\index{getParameters() (RRtoolbox.lib.plotter.Edger method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Edger.getParameters}\pysiglinewithargsret{\bfcode{getParameters}}{\emph{params=(`d'}, \emph{`sigmaColor'}, \emph{`sigmaSpace'}, \emph{`clipLimit'}, \emph{`tileGridSize'}, \emph{`isSIZE'}, \emph{`isEQUA'}, \emph{`isCLAHE'}, \emph{`isBFILTER'}, \emph{`th1'}, \emph{`th2'}, \emph{`size'}, \emph{`apertureSize'}, \emph{`L2gradient')}}{}
\end{fulllineitems}

\index{isActiveWindow() (RRtoolbox.lib.plotter.Edger method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Edger.isActiveWindow}\pysiglinewithargsret{\bfcode{isActiveWindow}}{}{}
\end{fulllineitems}

\index{isBFILTER (RRtoolbox.lib.plotter.Edger attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Edger.isBFILTER}\pysigline{\bfcode{isBFILTER}}
\end{fulllineitems}

\index{isCLAHE (RRtoolbox.lib.plotter.Edger attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Edger.isCLAHE}\pysigline{\bfcode{isCLAHE}}
\end{fulllineitems}

\index{isEQUA (RRtoolbox.lib.plotter.Edger attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Edger.isEQUA}\pysigline{\bfcode{isEQUA}}
\end{fulllineitems}

\index{isSIZE (RRtoolbox.lib.plotter.Edger attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Edger.isSIZE}\pysigline{\bfcode{isSIZE}}
\end{fulllineitems}

\index{load() (RRtoolbox.lib.plotter.Edger method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Edger.load}\pysiglinewithargsret{\bfcode{load}}{\emph{img}, \emph{compute=True}}{}
\end{fulllineitems}

\index{maxth (RRtoolbox.lib.plotter.Edger attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Edger.maxth}\pysigline{\bfcode{maxth}}
\end{fulllineitems}

\index{onTrackbar1() (RRtoolbox.lib.plotter.Edger method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Edger.onTrackbar1}\pysiglinewithargsret{\bfcode{onTrackbar1}}{\emph{*args}}{}
\end{fulllineitems}

\index{onTrackbar2() (RRtoolbox.lib.plotter.Edger method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Edger.onTrackbar2}\pysiglinewithargsret{\bfcode{onTrackbar2}}{\emph{*args}}{}
\end{fulllineitems}

\index{save() (RRtoolbox.lib.plotter.Edger method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Edger.save}\pysiglinewithargsret{\bfcode{save}}{\emph{strname=None}, \emph{ext='.png'}, \emph{name='img'}}{}
\end{fulllineitems}

\index{showgray (RRtoolbox.lib.plotter.Edger attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Edger.showgray}\pysigline{\bfcode{showgray}}
\end{fulllineitems}

\index{size (RRtoolbox.lib.plotter.Edger attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Edger.size}\pysigline{\bfcode{size}}
\end{fulllineitems}

\index{th1 (RRtoolbox.lib.plotter.Edger attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Edger.th1}\pysigline{\bfcode{th1}}
\end{fulllineitems}

\index{th2 (RRtoolbox.lib.plotter.Edger attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Edger.th2}\pysigline{\bfcode{th2}}
\end{fulllineitems}

\index{windowfunc() (RRtoolbox.lib.plotter.Edger method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Edger.windowfunc}\pysiglinewithargsret{\bfcode{windowfunc}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{Imtester (class in RRtoolbox.lib.plotter)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Imtester}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.plotter.}\bfcode{Imtester}}{\emph{img}, \emph{win='Imtester plot'}}{}
Bases: {\hyperref[RRtoolbox.lib:RRtoolbox.lib.plotter.Plotim]{\emph{\code{RRtoolbox.lib.plotter.Plotim}}}}

Used to test some concepts as thresholds and filters
\index{applythresh() (RRtoolbox.lib.plotter.Imtester static method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Imtester.applythresh}\pysiglinewithargsret{\strong{static }\bfcode{applythresh}}{\emph{img}, \emph{type}, \emph{adaptativetoggle}, \emph{threshtoggle}, \emph{th}, \emph{blocksz}, \emph{c}, \emph{i='`}, \emph{ti='`}, \emph{info='`}, \emph{title='`}}{}
\end{fulllineitems}

\index{builtcmd() (RRtoolbox.lib.plotter.Imtester method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Imtester.builtcmd}\pysiglinewithargsret{\bfcode{builtcmd}}{}{}
\end{fulllineitems}

\index{computefunc() (RRtoolbox.lib.plotter.Imtester method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Imtester.computefunc}\pysiglinewithargsret{\bfcode{computefunc}}{\emph{image=None}}{}
\end{fulllineitems}

\index{detectType() (RRtoolbox.lib.plotter.Imtester method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Imtester.detectType}\pysiglinewithargsret{\bfcode{detectType}}{\emph{type}, \emph{i='`}, \emph{info='`}}{}
\end{fulllineitems}

\index{formatinfo() (RRtoolbox.lib.plotter.Imtester static method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Imtester.formatinfo}\pysiglinewithargsret{\strong{static }\bfcode{formatinfo}}{\emph{info}, \emph{words=9}}{}
\end{fulllineitems}

\index{updatevisualization() (RRtoolbox.lib.plotter.Imtester method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Imtester.updatevisualization}\pysiglinewithargsret{\bfcode{updatevisualization}}{\emph{image}, \emph{channel}, \emph{th=None}, \emph{items=None}, \emph{thresh1=None}, \emph{thresh2=None}}{}
\end{fulllineitems}

\index{visualize() (RRtoolbox.lib.plotter.Imtester method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Imtester.visualize}\pysiglinewithargsret{\bfcode{visualize}}{}{}
\end{fulllineitems}

\index{windowfunc() (RRtoolbox.lib.plotter.Imtester method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Imtester.windowfunc}\pysiglinewithargsret{\bfcode{windowfunc}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{MatchExplorer (class in RRtoolbox.lib.plotter)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.MatchExplorer}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.plotter.}\bfcode{MatchExplorer}}{\emph{win}, \emph{img1}, \emph{img2}, \emph{kp\_pairs=()}, \emph{status=None}, \emph{H=None}, \emph{show=True}, \emph{block=True}, \emph{daemon=True}}{}
Bases: {\hyperref[RRtoolbox.lib:RRtoolbox.lib.plotter.Plotim]{\emph{\code{RRtoolbox.lib.plotter.Plotim}}}}

Draws a set of keypoint pairs obtained on a match method of a descriptor
on two images imgf and imgb. (backend: Plotim).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{win}} -- window's name (str)

\item {} 
\textbf{\texttt{img1}} -- image1 (numpy array)

\item {} 
\textbf{\texttt{img2}} -- image2 (numpy array)

\item {} 
\textbf{\texttt{kp\_pairs}} -- zip(keypoint1, keypoint2)

\item {} 
\textbf{\texttt{status}} -- obtained from cv2.findHomography

\item {} 
\textbf{\texttt{H}} -- obtained from cv2.findHomography (default=None)

\item {} 
\textbf{\texttt{show}} -- if True shows Plotim using block and daemon, else do not show

\item {} 
\textbf{\texttt{block}} -- if True it wait for window close, else it detaches

\item {} 
\textbf{\texttt{daemon}} -- if True window closes if main thread ends, else windows must be closed to main thread to end

\end{itemize}

\item[{Returns}] \leavevmode
Plotim object with visualization as self.rimg (image with matching result) (default=None)

\end{description}\end{quote}

\begin{notice}{note}{Note:}
It supports BGR and gray images.
\end{notice}
\index{drawline() (RRtoolbox.lib.plotter.MatchExplorer method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.MatchExplorer.drawline}\pysiglinewithargsret{\bfcode{drawline}}{}{}
Draws background visualization without interaction

\end{fulllineitems}

\index{drawrelation() (RRtoolbox.lib.plotter.MatchExplorer method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.MatchExplorer.drawrelation}\pysiglinewithargsret{\bfcode{drawrelation}}{}{}
Draw keypoints where pointer is placed and pressed

\end{fulllineitems}

\index{keyfunc() (RRtoolbox.lib.plotter.MatchExplorer method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.MatchExplorer.keyfunc}\pysiglinewithargsret{\bfcode{keyfunc}}{}{}
\end{fulllineitems}

\index{mousefunc() (RRtoolbox.lib.plotter.MatchExplorer method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.MatchExplorer.mousefunc}\pysiglinewithargsret{\bfcode{mousefunc}}{}{}
\end{fulllineitems}

\index{randomColor() (RRtoolbox.lib.plotter.MatchExplorer static method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.MatchExplorer.randomColor}\pysiglinewithargsret{\strong{static }\bfcode{randomColor}}{}{}
\end{fulllineitems}

\index{updaterenderer() (RRtoolbox.lib.plotter.MatchExplorer method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.MatchExplorer.updaterenderer}\pysiglinewithargsret{\bfcode{updaterenderer}}{\emph{img=None}, \emph{zoom=True}}{}
update renderer when called.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{img}} -- image to update in renderer, if None use self.img

\item {} 
\textbf{\texttt{zoom}} -- True to enable zoom, else updates with original img.

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Plotim (class in RRtoolbox.lib.plotter)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Plotim}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.plotter.}\bfcode{Plotim}}{\emph{win}, \emph{im=array({[}{[}1{]}{]})}, \emph{bgrcolor=(250}, \emph{243}, \emph{238)}}{}
Bases: \code{object}

Show and image with events, animations, controls, internal
commands and highly customizable by code.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{win}} -- window name

\item {} 
\textbf{\texttt{im}} -- image of numpy array

\item {} 
\textbf{\texttt{bgrcolor}} -- default color to use for transparent or background color.

\end{itemize}

\end{description}\end{quote}

\begin{notice}{warning}{Warning:}
Plotim is deprecated and will be replaced in the future (it was made to
test concepts). Originally it was made for windows but some functions
were removed to let it be multi-platform.
\end{notice}
\index{builtincmd() (RRtoolbox.lib.plotter.Plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Plotim.builtincmd}\pysiglinewithargsret{\bfcode{builtincmd}}{}{}
Internal cmd control

\end{fulllineitems}

\index{builtincontrol() (RRtoolbox.lib.plotter.Plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Plotim.builtincontrol}\pysiglinewithargsret{\bfcode{builtincontrol}}{\emph{control=False}}{}
Internal control. use self.usecontrol = True to activate.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{control}} -- if True, use control key.

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{builtinplot() (RRtoolbox.lib.plotter.Plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Plotim.builtinplot}\pysiglinewithargsret{\bfcode{builtinplot}}{\emph{pixel=None}, \emph{useritems=None}, \emph{flag=1}, \emph{xpad=0}, \emph{ypad=0}, \emph{bgrcolor=None}, \emph{alpha=None}}{}
Internal plot.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{pixel}} -- pixel color where mouse is placed (placed for better control). Color can be from
real image, showed image, original image or rendered image, or any color.

\item {} 
\textbf{\texttt{useritems}} -- items to show.

\item {} 
\textbf{\texttt{flag}} -- 
flag for position (default=0).
\begin{itemize}
\item {} 
flag==0 : foreground to left up.

\item {} 
flag==1 : foreground to left down.

\item {} 
flag==2 : foreground to right up.

\item {} 
flag==3 : foreground to right down.

\item {} 
flag==4 : foreground at center of background.

\item {} 
flag==5 : XY 0,0 is at center of background.

\item {} 
flag==6 : XY 0,0 is at center of foreground.

\item {} 
flag==7 : XY 0,0 is at right down of foreground.

\end{itemize}


\item {} 
\textbf{\texttt{xpad}} -- padding in x

\item {} 
\textbf{\texttt{ypad}} -- padding in y

\item {} 
\textbf{\texttt{bgrcolor}} -- background color

\item {} 
\textbf{\texttt{alpha}} -- alpha mask or value for transparency

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{builtinwindow() (RRtoolbox.lib.plotter.Plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Plotim.builtinwindow}\pysiglinewithargsret{\bfcode{builtinwindow}}{}{}
loads windowfunc, showfunc, starts window thread and mousecallback.

\end{fulllineitems}

\index{clean() (RRtoolbox.lib.plotter.Plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Plotim.clean}\pysiglinewithargsret{\bfcode{clean}}{}{}
Attempt to clean the plotter dictionary for an error in
garbage collection.
:return:

\end{fulllineitems}

\index{closefunc() (RRtoolbox.lib.plotter.Plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Plotim.closefunc}\pysiglinewithargsret{\bfcode{closefunc}}{}{}
Decoupled close function for Plotim (replace self.closefunc).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- Plotim instance

\end{description}\end{quote}

\end{fulllineitems}

\index{cmdfunc() (RRtoolbox.lib.plotter.Plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Plotim.cmdfunc}\pysiglinewithargsret{\bfcode{cmdfunc}}{\emph{execute=False}}{}
command function and decoupled cmd solver for Plotim. (repalce self.cmdfunc)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{self}} -- 

\item {} 
\textbf{\texttt{execute}} -- True, enable execution of commands, False, disable execution.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{errorbackground (RRtoolbox.lib.plotter.Plotim attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Plotim.errorbackground}\pysigline{\bfcode{errorbackground}}
\end{fulllineitems}

\index{formatcmd() (RRtoolbox.lib.plotter.Plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Plotim.formatcmd}\pysiglinewithargsret{\bfcode{formatcmd}}{\emph{cmd}, \emph{references=(`+'}, \emph{`-`}, \emph{`*'}, \emph{`=')}, \emph{lmissing='self.'}}{}
Decoupled cmd formatter for cmdfunc and Plotim.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{self}} -- Plotim instance

\item {} 
\textbf{\texttt{cmd}} -- command

\item {} 
\textbf{\texttt{references}} -- 

\item {} 
\textbf{\texttt{lmissing}} -- assumed missing part in command

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{help() (RRtoolbox.lib.plotter.Plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Plotim.help}\pysiglinewithargsret{\bfcode{help}}{\emph{showAll=False}}{}
function to print the quick help for the user with all the commands

\end{fulllineitems}

\index{init() (RRtoolbox.lib.plotter.Plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Plotim.init}\pysiglinewithargsret{\bfcode{init}}{}{}
Pseudo \_\_init\_\_. it is used to restart default
values without destroying configurations.

\end{fulllineitems}

\index{keyfunc() (RRtoolbox.lib.plotter.Plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Plotim.keyfunc}\pysiglinewithargsret{\bfcode{keyfunc}}{}{}
Decoupled key function for Plotim (replace self.keyfunc).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- Plotim instance

\end{description}\end{quote}

\end{fulllineitems}

\index{makeoverlay() (RRtoolbox.lib.plotter.Plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Plotim.makeoverlay}\pysiglinewithargsret{\bfcode{makeoverlay}}{\emph{items}, \emph{xpad=0}, \emph{ypad=0}, \emph{bgrcolor=None}, \emph{alpha=None}}{}
overlay items over image.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{self}} -- instance

\item {} 
\textbf{\texttt{items}} -- list of object to overlay

\item {} 
\textbf{\texttt{xpad}} -- pad in x

\item {} 
\textbf{\texttt{ypad}} -- pad in y

\item {} 
\textbf{\texttt{bgrcolor}} -- background color

\item {} 
\textbf{\texttt{alpha}} -- transparency color

\end{itemize}

\item[{Returns}] \leavevmode
overlayed

\end{description}\end{quote}

\end{fulllineitems}

\index{mousefunc() (RRtoolbox.lib.plotter.Plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Plotim.mousefunc}\pysiglinewithargsret{\bfcode{mousefunc}}{}{}
Decoupled mouse function for Plotim (replace self.mousefunc).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- Plotim instance

\end{description}\end{quote}

\end{fulllineitems}

\index{onmouse() (RRtoolbox.lib.plotter.Plotim static method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Plotim.onmouse}\pysiglinewithargsret{\strong{static }\bfcode{onmouse}}{\emph{event}, \emph{x}, \emph{y}, \emph{flags}, \emph{self}}{}
Mouse event function for Plotim. (replace self.mousefunc)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{event}} -- mouse event

\item {} 
\textbf{\texttt{x}} -- x position

\item {} 
\textbf{\texttt{y}} -- y postion

\item {} 
\textbf{\texttt{flags}} -- mouse flag to use in control (it represents clicks)

\item {} 
\textbf{\texttt{self}} -- Plotim object

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{plotatpointer() (RRtoolbox.lib.plotter.Plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Plotim.plotatpointer}\pysiglinewithargsret{\bfcode{plotatpointer}}{\emph{items}, \emph{img=None}, \emph{x=0}, \emph{y=0}, \emph{flag=6}, \emph{xpad=0}, \emph{ypad=0}, \emph{bgrcolor=None}, \emph{alpha=None}, \emph{pixel=None}}{}
Plot message where mouse pointer is.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{items}} -- list of items supported by \code{self.makeoverlay()}

\item {} 
\textbf{\texttt{img}} -- image to place in items. If None it uses self.remg

\item {} 
\textbf{\texttt{x}} -- x position

\item {} 
\textbf{\texttt{y}} -- y position

\item {} 
\textbf{\texttt{flag}} -- 
flag for position (default=0).
\begin{itemize}
\item {} 
flag==0 : foreground to left up.

\item {} 
flag==1 : foreground to left down.

\item {} 
flag==2 : foreground to right up.

\item {} 
flag==3 : foreground to right down.

\item {} 
flag==4 : foreground at center of background.

\item {} 
flag==5 : XY 0,0 is at center of background.

\item {} 
flag==6 : XY 0,0 is at center of foreground.

\item {} 
flag==7 : XY 0,0 is at right down of foreground.

\end{itemize}


\item {} 
\textbf{\texttt{xpad}} -- padding in x

\item {} 
\textbf{\texttt{ypad}} -- padding in y

\item {} 
\textbf{\texttt{bgrcolor}} -- background color

\item {} 
\textbf{\texttt{alpha}} -- alpha mask or value for transparency

\item {} 
\textbf{\texttt{pixel}} -- color to add as item im items,

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{plotatxy() (RRtoolbox.lib.plotter.Plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Plotim.plotatxy}\pysiglinewithargsret{\bfcode{plotatxy}}{\emph{items}, \emph{img=None}, \emph{x=0}, \emph{y=0}, \emph{flag=0}, \emph{xpad=0}, \emph{ypad=0}, \emph{bgrcolor=None}, \emph{alpha=None}}{}
Plot message in xy position.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{items}} -- list of items supported by {\hyperref[RRtoolbox.lib:RRtoolbox.lib.plotter.Plotim.makeoverlay]{\emph{\code{makeoverlay()}}}}

\item {} 
\textbf{\texttt{img}} -- image to place in items. If None it uses self.remg

\item {} 
\textbf{\texttt{x}} -- x position

\item {} 
\textbf{\texttt{y}} -- y position

\item {} 
\textbf{\texttt{flag}} -- 
flag for position (default=0).
\begin{itemize}
\item {} 
flag==0 : foreground to left up.

\item {} 
flag==1 : foreground to left down.

\item {} 
flag==2 : foreground to right up.

\item {} 
flag==3 : foreground to right down.

\item {} 
flag==4 : foreground at center of background.

\item {} 
flag==5 : XY 0,0 is at center of background.

\item {} 
flag==6 : XY 0,0 is at center of foreground.

\item {} 
flag==7 : XY 0,0 is at right down of foreground.

\end{itemize}


\item {} 
\textbf{\texttt{xpad}} -- padding in x

\item {} 
\textbf{\texttt{ypad}} -- padding in y

\item {} 
\textbf{\texttt{bgrcolor}} -- background color

\item {} 
\textbf{\texttt{alpha}} -- alpha mask or value for transparency

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{plotintime() (RRtoolbox.lib.plotter.Plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Plotim.plotintime}\pysiglinewithargsret{\bfcode{plotintime}}{\emph{items=None}, \emph{wait=2}, \emph{img=None}, \emph{bgrcolor=None}}{}
plots messages and events.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{items}} -- list of items supported by {\hyperref[RRtoolbox.lib:RRtoolbox.lib.plotter.Plotim.makeoverlay]{\emph{\code{makeoverlay()}}}}

\item {} 
\textbf{\texttt{wait}} -- time of message.

\item {} 
\textbf{\texttt{img}} -- image to place in items. If None it uses self.remg

\item {} 
\textbf{\texttt{bgrcolor}} -- color of message.

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{real2render() (RRtoolbox.lib.plotter.Plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Plotim.real2render}\pysiglinewithargsret{\bfcode{real2render}}{\emph{x}, \emph{y}, \emph{astype=None}}{}
from real coordinates get rendered coordinates.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{x}} -- real x

\item {} 
\textbf{\texttt{y}} -- real y

\item {} 
\textbf{\texttt{astype}} -- (np.int32) return as the specified type

\end{itemize}

\item[{Returns}] \leavevmode
rendered x, rendered y

\end{description}\end{quote}

\end{fulllineitems}

\index{render2real() (RRtoolbox.lib.plotter.Plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Plotim.render2real}\pysiglinewithargsret{\bfcode{render2real}}{\emph{rx}, \emph{ry}, \emph{astype=\textless{}type `numpy.int32'\textgreater{}}}{}
from rendered coordinates get real coordinates.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{rx}} -- rendered x

\item {} 
\textbf{\texttt{ry}} -- rendered y

\item {} 
\textbf{\texttt{astype}} -- (np.int32) return as the specified type

\end{itemize}

\item[{Returns}] \leavevmode
real x, real y

\end{description}\end{quote}

\end{fulllineitems}

\index{rx1 (RRtoolbox.lib.plotter.Plotim attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Plotim.rx1}\pysigline{\bfcode{rx1}}
\end{fulllineitems}

\index{rx2 (RRtoolbox.lib.plotter.Plotim attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Plotim.rx2}\pysigline{\bfcode{rx2}}
\end{fulllineitems}

\index{ry1 (RRtoolbox.lib.plotter.Plotim attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Plotim.ry1}\pysigline{\bfcode{ry1}}
\end{fulllineitems}

\index{ry2 (RRtoolbox.lib.plotter.Plotim attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Plotim.ry2}\pysigline{\bfcode{ry2}}
\end{fulllineitems}

\index{save() (RRtoolbox.lib.plotter.Plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Plotim.save}\pysiglinewithargsret{\bfcode{save}}{\emph{strname=None}, \emph{ext='.png'}, \emph{name='img'}}{}
Save image (save image if not Qt backend is installed)
:param strname: name to save, a label with \{win\} can be used to be replaced with the plot win name
:param ext: (''.png'') extension.
:param name: (``img'') name of image object from self. default is ``img'' that is self.img
\begin{quote}

(it allows better control to get custom image)
\end{quote}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
True if saved, False if not saved (possibly because folder does not exists)

\end{description}\end{quote}

\end{fulllineitems}

\index{show() (RRtoolbox.lib.plotter.Plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Plotim.show}\pysiglinewithargsret{\bfcode{show}}{\emph{frames=None}, \emph{block=True}, \emph{daemon=False}, \emph{clean=True}}{}
Show function. calls buildinwindow, handles key presses and close events.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{frames}} -- show number of frames and close.

\item {} 
\textbf{\texttt{block}} -- if True it wait for window close, else it detaches (Experimental)

\item {} 
\textbf{\texttt{daemon}} -- if True window closes if main thread ends,
else windows must be closed to main thread to end (Experimental)

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{showfunc() (RRtoolbox.lib.plotter.Plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Plotim.showfunc}\pysiglinewithargsret{\bfcode{showfunc}}{\emph{img=None}}{}
Decoupled show function for Plotim (replace self.showfunc).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{self}} -- Plotim instance

\item {} 
\textbf{\texttt{img}} -- image to show

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{textbackground (RRtoolbox.lib.plotter.Plotim attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Plotim.textbackground}\pysigline{\bfcode{textbackground}}
\end{fulllineitems}

\index{updaterenderer() (RRtoolbox.lib.plotter.Plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Plotim.updaterenderer}\pysiglinewithargsret{\bfcode{updaterenderer}}{\emph{img=None}, \emph{zoom=True}}{}
update renderer when called.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{img}} -- image to update in renderer, if None use self.img

\item {} 
\textbf{\texttt{zoom}} -- True to enable zoom, else updates with original img.

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{windowfunc() (RRtoolbox.lib.plotter.Plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.Plotim.windowfunc}\pysiglinewithargsret{\bfcode{windowfunc}}{}{}
Decoupled window function for Plotim (replace self.windowfunc).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- Plotim instance

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{background() (in module RRtoolbox.lib.plotter)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.background}\pysiglinewithargsret{\code{RRtoolbox.lib.plotter.}\bfcode{background}}{\emph{color}, \emph{x=1}, \emph{y=1}, \emph{flag=0}}{}
Creates background rectangle.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{color}} -- main color.

\item {} 
\textbf{\texttt{x}} -- x pixels in axis x.

\item {} 
\textbf{\texttt{y}} -- y pixels in axis y.

\item {} 
\textbf{\texttt{flag}} -- Not implemented.

\end{itemize}

\item[{Returns}] \leavevmode
image of shape y,x and ndim == color.ndim.

\end{description}\end{quote}

\end{fulllineitems}

\index{convert2bgr() (in module RRtoolbox.lib.plotter)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.convert2bgr}\pysiglinewithargsret{\code{RRtoolbox.lib.plotter.}\bfcode{convert2bgr}}{\emph{src}, \emph{bgrcolor=None}}{}
Tries to convert any image format to BGR.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{src}} -- source image.

\item {} 
\textbf{\texttt{bgrcolor}} -- background or transparent color.

\end{itemize}

\item[{Returns}] \leavevmode
BGR array image.

\end{description}\end{quote}

\end{fulllineitems}

\index{convert2bgra() (in module RRtoolbox.lib.plotter)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.convert2bgra}\pysiglinewithargsret{\code{RRtoolbox.lib.plotter.}\bfcode{convert2bgra}}{\emph{src}, \emph{bgracolor=None}, \emph{transparency=None}}{}
Tries to convert any image format to BGRA.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{src}} -- source image.

\item {} 
\textbf{\texttt{bgracolor}} -- background or transparent color.

\item {} 
\textbf{\texttt{transparency}} -- mask or A channel.
(typically source image has not A channel, so user can provide it)

\end{itemize}

\item[{Returns}] \leavevmode
BGRA array image.

\end{description}\end{quote}

\end{fulllineitems}

\index{echo() (in module RRtoolbox.lib.plotter)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.echo}\pysiglinewithargsret{\code{RRtoolbox.lib.plotter.}\bfcode{echo}}{\emph{obj}}{}
Printer (used when user wants to print an object from Plotim)
:param obj: object

\end{fulllineitems}

\index{fastplt() (in module RRtoolbox.lib.plotter)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.fastplt}\pysiglinewithargsret{\code{RRtoolbox.lib.plotter.}\bfcode{fastplt}}{\emph{image}, \emph{cmap=None}, \emph{title='visualazor'}, \emph{win=None}, \emph{block=False}, \emph{daemon=False}}{}
Fast plot.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{image}} -- image to show

\item {} 
\textbf{\texttt{cmap}} -- ``gray'' or None

\item {} 
\textbf{\texttt{title}} -- title of subplot

\item {} 
\textbf{\texttt{win}} -- title of window

\item {} 
\textbf{\texttt{block}} -- if True it wait for window close, else it detaches (Experimental)

\item {} 
\textbf{\texttt{daemon}} -- if True window closes if main thread ends, else windows
must be closed to main thread to end (Experimental)

\end{itemize}

\item[{Returns}] \leavevmode
plt

\end{description}\end{quote}

\end{fulllineitems}

\index{graph\_filter() (in module RRtoolbox.lib.plotter)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.graph_filter}\pysiglinewithargsret{\code{RRtoolbox.lib.plotter.}\bfcode{graph\_filter}}{\emph{filters}, \emph{levels=None}, \emph{titles=None}, \emph{win=None}, \emph{single=True}, \emph{legend=True}, \emph{annotate=True}, \emph{cols=3}, \emph{scale=0.07}, \emph{show=True}, \emph{lxp=None}, \emph{lyp=None}}{}
Graph filter with standard data to watch response.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{filters}} -- list of filters

\item {} 
\textbf{\texttt{levels}} -- numpy array with values. if None tries to fit data or assumes from 0 to 255

\item {} 
\textbf{\texttt{titles}} -- list of titles for each filter in filters. if None creates the titles

\item {} 
\textbf{\texttt{win}} -- window name

\item {} 
\textbf{\texttt{single}} -- True to plot all filters in one plot. else separate each filter in a plot.

\item {} 
\textbf{\texttt{legend}} -- True to add legends.

\item {} 
\textbf{\texttt{annotate}} -- True to add annotations.

\item {} 
\textbf{\texttt{cols}} -- number of columns to create plots

\item {} 
\textbf{\texttt{scale}} -- factor from maximum to draw annotations

\item {} 
\textbf{\texttt{show}} -- to show the figure

\end{itemize}

\item[{Returns}] \leavevmode
figure

\end{description}\end{quote}

\end{fulllineitems}

\index{limitaxis() (in module RRtoolbox.lib.plotter)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.limitaxis}\pysiglinewithargsret{\code{RRtoolbox.lib.plotter.}\bfcode{limitaxis}}{\emph{c}, \emph{maxc}, \emph{minc=0}}{}
Limit value in axis.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{c}} -- value

\item {} 
\textbf{\texttt{maxc}} -- max c value.

\item {} 
\textbf{\texttt{minc}} -- min c value.

\end{itemize}

\item[{Returns}] \leavevmode
limited c value c E {[}minc,maxc{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{plotPointsContour() (in module RRtoolbox.lib.plotter)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.plotPointsContour}\pysiglinewithargsret{\code{RRtoolbox.lib.plotter.}\bfcode{plotPointsContour}}{\emph{pts}, \emph{ax=None}, \emph{lcor='k'}, \emph{pcor=None}, \emph{deg=None}, \emph{annotate=True}, \emph{width=0.004}, \emph{label='pt\{pt\}(\{x\}}, \emph{\{y\}}, \emph{\{a\})'}, \emph{arrowprops=None}}{}
Plots points and joining lines in axes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{pts}} -- points. {[}(x0,y0)...(xN,yN){]}

\item {} 
\textbf{\texttt{ax}} -- axes handle to draw points.

\item {} 
\textbf{\texttt{lcor}} -- color of joining lines.

\item {} 
\textbf{\texttt{pcor}} -- color of points. If specified uses lines, else vectors.

\item {} 
\textbf{\texttt{deg}} -- angle of vertex, if True in degrees, if False in radians, if None do not add.

\item {} 
\textbf{\texttt{annotate}} -- (True) True to annotate

\item {} 
\textbf{\texttt{width}} -- adjust width of lines

\item {} 
\textbf{\texttt{label}} -- string to format point labels. add the point with \{pt\},
x and y coordinates with \{x\} and \{y\}, and angle with \{a\}. By default
label is `pt\{pt\}(\{x\}, \{y\}, \{a\})'.

\item {} 
\textbf{\texttt{arrowprops}} -- dictionary to modify array properties

\end{itemize}

\item[{Returns}] \leavevmode
axes

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{RRtoolbox.lib.root module}
\label{RRtoolbox.lib:rrtoolbox-lib-root-module}\label{RRtoolbox.lib:module-RRtoolbox.lib.root}\index{RRtoolbox.lib.root (module)}
This module holds core-like methods for library modules but not for the hole package
\index{Controlstdout (class in RRtoolbox.lib.root)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.Controlstdout}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.root.}\bfcode{Controlstdout}}{\emph{disable=True}, \emph{buffer=None}}{}
Bases: \code{object}

Context manager to control output to stdout
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{disable}} -- if True suppress output.

\item {} 
\textbf{\texttt{buffer}} -- (None) if True creates a buffer to collect all data
printed to the stdout which can be retrieved with self.buffered.
A file can be given but if it is write-only it cannot retrieve
data to self.buffered so ``w+'' is recommended to be used with self.buffered.

\end{itemize}

\end{description}\end{quote}

\begin{notice}{warning}{Warning:}
If a references to sys.stdout is kept before the Controlstdout
instance then output can be printed trough it and cannot be
controlled by the Controlstdout context.
\end{notice}

\end{fulllineitems}

\index{FactorConvert (class in RRtoolbox.lib.root)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.FactorConvert}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.root.}\bfcode{FactorConvert}}{\emph{factor=None}, \emph{abbreviate=True}}{}
Bases: \code{object}

Keep track of factor and converts to any available factor.
\index{convert() (RRtoolbox.lib.root.FactorConvert method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.FactorConvert.convert}\pysiglinewithargsret{\bfcode{convert}}{\emph{factor}, \emph{to=None}}{}
Convert from actual factor to another factor.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{factor}} -- number

\item {} 
\textbf{\texttt{to}} -- factor to convert

\end{itemize}

\item[{Returns}] \leavevmode
converted value, units

\end{description}\end{quote}

\end{fulllineitems}

\index{convert2sample() (RRtoolbox.lib.root.FactorConvert method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.FactorConvert.convert2sample}\pysiglinewithargsret{\bfcode{convert2sample}}{\emph{factor}, \emph{to=None}}{}
Convert to resemble sample.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{factor}} -- number

\item {} 
\textbf{\texttt{to}} -- sample factor.

\end{itemize}

\item[{Returns}] \leavevmode
converted value, units

\end{description}\end{quote}

\end{fulllineitems}

\index{exactFactorIndex() (RRtoolbox.lib.root.FactorConvert method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.FactorConvert.exactFactorIndex}\pysiglinewithargsret{\bfcode{exactFactorIndex}}{\emph{key}}{}
Find the index of a factor that contains a key.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{key}} -- anything to look in factors (i.e. factor name, factor value, abbreviation).

\item[{Returns}] \leavevmode
factor structure, else None.

\end{description}\end{quote}

\end{fulllineitems}

\index{factor (RRtoolbox.lib.root.FactorConvert attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.FactorConvert.factor}\pysigline{\bfcode{factor}}
\end{fulllineitems}

\index{factors (RRtoolbox.lib.root.FactorConvert attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.FactorConvert.factors}\pysigline{\bfcode{factors}}
\end{fulllineitems}

\index{getFactor() (RRtoolbox.lib.root.FactorConvert method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.FactorConvert.getFactor}\pysiglinewithargsret{\bfcode{getFactor}}{\emph{key}}{}
Tries to find factor value in factors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{key}} -- anything to look in factors (i.e. factor name, factor value, abbreviation).
If key is a factor value it will look for the nearest factor value.

\item[{Returns}] \leavevmode
factor structure, else raises error.

\end{description}\end{quote}

\end{fulllineitems}

\index{nearFactorIndex() (RRtoolbox.lib.root.FactorConvert method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.FactorConvert.nearFactorIndex}\pysiglinewithargsret{\bfcode{nearFactorIndex}}{\emph{factor}}{}
Find the index of nearest factor value.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{factor}} -- factor value.

\item[{Returns}] \leavevmode
factor structure near factor value.

\end{description}\end{quote}

\end{fulllineitems}

\index{parts() (RRtoolbox.lib.root.FactorConvert static method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.FactorConvert.parts}\pysiglinewithargsret{\strong{static }\bfcode{parts}}{\emph{value}, \emph{precision=4}}{}
Get number parts.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{value}} -- number

\item {} 
\textbf{\texttt{precision}} -- decimal precision

\end{itemize}

\item[{Returns}] \leavevmode
({[}... ,Hundreds, Tens, Ones{]},{[}Tenths, ...{]})

\end{description}\end{quote}

\end{fulllineitems}

\index{split() (RRtoolbox.lib.root.FactorConvert static method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.FactorConvert.split}\pysiglinewithargsret{\strong{static }\bfcode{split}}{\emph{value}}{}
Get number fraction.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{value}} -- number

\item[{Returns}] \leavevmode
integer, fraction

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Magnitude (class in RRtoolbox.lib.root)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.Magnitude}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.root.}\bfcode{Magnitude}}{\emph{value=0}, \emph{factor=None}, \emph{unit=None}, \emph{precision=None}, \emph{abbreviate=False}}{}
Bases: \code{object}
\index{format\_value() (RRtoolbox.lib.root.Magnitude method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.Magnitude.format_value}\pysiglinewithargsret{\bfcode{format\_value}}{\emph{value}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{NameSpace (class in RRtoolbox.lib.root)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.NameSpace}\pysigline{\strong{class }\code{RRtoolbox.lib.root.}\bfcode{NameSpace}}
Bases: \code{object}

used to store variables

\end{fulllineitems}

\index{NoParserFound}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.NoParserFound}\pysigline{\strong{exception }\code{RRtoolbox.lib.root.}\bfcode{NoParserFound}}
Bases: \code{exceptions.Exception}

\end{fulllineitems}

\index{NotCallable}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.NotCallable}\pysigline{\strong{exception }\code{RRtoolbox.lib.root.}\bfcode{NotCallable}}
Bases: \code{exceptions.Exception}

Defines objectGetter error: given object is not callable.

\end{fulllineitems}

\index{NotCreatable}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.NotCreatable}\pysigline{\strong{exception }\code{RRtoolbox.lib.root.}\bfcode{NotCreatable}}
Bases: \code{exceptions.Exception}

Defines objectGetter error: objectGetter cannot create new object.

\end{fulllineitems}

\index{Profiler (class in RRtoolbox.lib.root)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.Profiler}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.root.}\bfcode{Profiler}}{\emph{msg=None}, \emph{tag=None}}{}
Bases: \code{object}
\begin{quote}

profiler for code points
\begin{quote}\begin{description}
\item[{param msg}] \leavevmode
custom comment for profiling point

\item[{param tag}] \leavevmode
classification tag

\item[{parameter space}] \leavevmode
('' '')

\item[{parameter format\_line}] \leavevmode
(``\{space\}\{tag\}\{msg\}\{time\}'')

\item[{parameter format\_structure}] \leavevmode
(``

\end{description}\end{quote}
\end{quote}
\begin{description}
\item[{\{space\}{[}\{tag\}\{msg\}\{time\}\{child\}{]}\{side\}'')}] \leavevmode\begin{quote}\begin{description}
\item[{parameter points}] \leavevmode
profile instaces which are divided in ``side'' or ``children'' points
according if they are side by side or are inside of the profiler.

\end{description}\end{quote}

\end{description}
\index{close() (RRtoolbox.lib.root.Profiler method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.Profiler.close}\pysiglinewithargsret{\bfcode{close}}{}{}
close profiler and all their points

\end{fulllineitems}

\index{formatter() (RRtoolbox.lib.root.Profiler method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.Profiler.formatter}\pysiglinewithargsret{\bfcode{formatter}}{\emph{level}, \emph{tag}, \emph{msg}, \emph{time}}{}
format profiling point arguments.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{level}} -- 

\item {} 
\textbf{\texttt{tag}} -- classification tag

\item {} 
\textbf{\texttt{msg}} -- custom comment of profiling point

\item {} 
\textbf{\texttt{time}} -- time of profiling

\end{itemize}

\item[{Returns}] \leavevmode
formatted (spacing, tag, msg, time)

\end{description}\end{quote}

\end{fulllineitems}

\index{lines\_formatted() (RRtoolbox.lib.root.Profiler method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.Profiler.lines_formatted}\pysiglinewithargsret{\bfcode{lines\_formatted}}{\emph{collapse=None}}{}
generate string lines
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{collapse}} -- list for collapsing repeated tags or messages.

\item[{Returns}] \leavevmode
list of lines

\end{description}\end{quote}

\end{fulllineitems}

\index{lines\_unformatted() (RRtoolbox.lib.root.Profiler method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.Profiler.lines_unformatted}\pysiglinewithargsret{\bfcode{lines\_unformatted}}{\emph{collapse=None}}{}
generate structure lines
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{collapse}} -- list for collapsing repeated tags or messages.

\item[{Returns}] \leavevmode
generator with outputs (level, tag, msg, time)

\end{description}\end{quote}

\end{fulllineitems}

\index{open\_point() (RRtoolbox.lib.root.Profiler method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.Profiler.open_point}\pysiglinewithargsret{\bfcode{open\_point}}{\emph{msg=None}, \emph{tag=None}}{}
Open a profiling point to track time.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{msg}} -- custom comment for profiling point

\item {} 
\textbf{\texttt{tag}} -- classification tag

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{restructure() (RRtoolbox.lib.root.Profiler method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.Profiler.restructure}\pysiglinewithargsret{\bfcode{restructure}}{\emph{structure}, \emph{collapse}}{}
reprocess an already created structure.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{structure}} -- structure.

\item {} 
\textbf{\texttt{collapse}} -- list for collapsing repeated tags or messages.

\end{itemize}

\item[{Returns}] \leavevmode
reprocessed structure

\end{description}\end{quote}

\end{fulllineitems}

\index{string\_lines() (RRtoolbox.lib.root.Profiler method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.Profiler.string_lines}\pysiglinewithargsret{\bfcode{string\_lines}}{}{}
string with plain structure of profiling

\end{fulllineitems}

\index{string\_structured() (RRtoolbox.lib.root.Profiler method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.Profiler.string_structured}\pysiglinewithargsret{\bfcode{string\_structured}}{\emph{collapse=None}, \emph{structure=None}}{}
string with plain structure of profiling
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{collapse}} -- list for collapsing repeated tags or messages.

\item {} 
\textbf{\texttt{structure}} -- (None) uses and already created structure. If None
it creates the structure.

\end{itemize}

\item[{Returns}] \leavevmode
string

\end{description}\end{quote}

\end{fulllineitems}

\index{structure() (RRtoolbox.lib.root.Profiler method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.Profiler.structure}\pysiglinewithargsret{\bfcode{structure}}{\emph{collapse=None}}{}
profiling structure.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{collapse}} -- list for collapsing repeated tags or messages.

\item[{Returns}] \leavevmode
structure with format {[}tag,msg,time,children{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{time (RRtoolbox.lib.root.Profiler attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.Profiler.time}\pysigline{\bfcode{time}}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
overall time of profiling

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{StdoutLOG (class in RRtoolbox.lib.root)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.StdoutLOG}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.root.}\bfcode{StdoutLOG}}{\emph{path}, \emph{mode='w+'}, \emph{chain=False}}{}
simple logger to save stdout output
so anything printed in the console is logged to a file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{path}} -- path to logging file

\item {} 
\textbf{\texttt{mode}} -- mode for opening the file.

\item {} 
\textbf{\texttt{chain}} -- if True closes previous logs and continues with new log

\end{itemize}

\end{description}\end{quote}
\index{close() (RRtoolbox.lib.root.StdoutLOG method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.StdoutLOG.close}\pysiglinewithargsret{\bfcode{close}}{\emph{**kwargs}}{}
\end{fulllineitems}

\index{flush() (RRtoolbox.lib.root.StdoutLOG method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.StdoutLOG.flush}\pysiglinewithargsret{\bfcode{flush}}{\emph{**kwargs}}{}
\end{fulllineitems}

\index{printline() (RRtoolbox.lib.root.StdoutLOG method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.StdoutLOG.printline}\pysiglinewithargsret{\bfcode{printline}}{\emph{text}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{printlines() (RRtoolbox.lib.root.StdoutLOG method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.StdoutLOG.printlines}\pysiglinewithargsret{\bfcode{printlines}}{\emph{lines}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{write() (RRtoolbox.lib.root.StdoutLOG method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.StdoutLOG.write}\pysiglinewithargsret{\bfcode{write}}{\emph{text}, \emph{**kwargs}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{StdoutMULTI (class in RRtoolbox.lib.root)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.StdoutMULTI}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.root.}\bfcode{StdoutMULTI}}{\emph{filelist}}{}
Enclose several file-like objects.

:param filelist = list of file-like objects
\index{close() (RRtoolbox.lib.root.StdoutMULTI method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.StdoutMULTI.close}\pysiglinewithargsret{\bfcode{close}}{\emph{**kwargs}}{}
\end{fulllineitems}

\index{flush() (RRtoolbox.lib.root.StdoutMULTI method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.StdoutMULTI.flush}\pysiglinewithargsret{\bfcode{flush}}{\emph{**kwargs}}{}
\end{fulllineitems}

\index{printline() (RRtoolbox.lib.root.StdoutMULTI method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.StdoutMULTI.printline}\pysiglinewithargsret{\bfcode{printline}}{\emph{text}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{printlines() (RRtoolbox.lib.root.StdoutMULTI method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.StdoutMULTI.printlines}\pysiglinewithargsret{\bfcode{printlines}}{\emph{lines}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{write() (RRtoolbox.lib.root.StdoutMULTI method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.StdoutMULTI.write}\pysiglinewithargsret{\bfcode{write}}{\emph{text}, \emph{**kwargs}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{StdoutSIM (class in RRtoolbox.lib.root)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.StdoutSIM}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.root.}\bfcode{StdoutSIM}}{\emph{disable=False}, \emph{stdout=None}}{}
simple logger to simulate stdout output
\index{close() (RRtoolbox.lib.root.StdoutSIM method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.StdoutSIM.close}\pysiglinewithargsret{\bfcode{close}}{}{}
\end{fulllineitems}

\index{flush() (RRtoolbox.lib.root.StdoutSIM method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.StdoutSIM.flush}\pysiglinewithargsret{\bfcode{flush}}{}{}
\end{fulllineitems}

\index{printline() (RRtoolbox.lib.root.StdoutSIM method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.StdoutSIM.printline}\pysiglinewithargsret{\bfcode{printline}}{\emph{text}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{printlines() (RRtoolbox.lib.root.StdoutSIM method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.StdoutSIM.printlines}\pysiglinewithargsret{\bfcode{printlines}}{\emph{lines}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{write() (RRtoolbox.lib.root.StdoutSIM method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.StdoutSIM.write}\pysiglinewithargsret{\bfcode{write}}{\emph{text}, \emph{**kwargs}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{TimeCode (class in RRtoolbox.lib.root)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.TimeCode}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.root.}\bfcode{TimeCode}}{\emph{msg=None}, \emph{factor=None}, \emph{precision=None}, \emph{abv=None}, \emph{endmsg='\{time\}n'}, \emph{enableMsg=True}, \emph{printfunc=None}, \emph{profiler=None}, \emph{profile\_point=None}}{}
Bases: \code{object}

Context to profile code by printing a prelude and prologue with time.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{msg}} -- prelude or description message

\item {} 
\textbf{\texttt{factor}} -- factor supported by FactorConvert class

\item {} 
\textbf{\texttt{precision}} -- number of digits after a float point

\item {} 
\textbf{\texttt{abv}} -- if True prints ``s'', if False ``seconds'' for time

\item {} 
\textbf{\texttt{endmsg}} -- prologue message

\item {} 
\textbf{\texttt{enableMsg}} -- (True) A flag specifying if context
should be printed or not.

\item {} 
\textbf{\texttt{printfunc}} -- function to print messages. By default it
is sys.stdout.write

\end{itemize}

\end{description}\end{quote}
\index{time (RRtoolbox.lib.root.TimeCode attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.TimeCode.time}\pysigline{\bfcode{time}}
\end{fulllineitems}

\index{time\_end (RRtoolbox.lib.root.TimeCode attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.TimeCode.time_end}\pysigline{\bfcode{time\_end}}
\end{fulllineitems}


\end{fulllineitems}

\index{TimeOutException}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.TimeOutException}\pysigline{\strong{exception }\code{RRtoolbox.lib.root.}\bfcode{TimeOutException}}
Bases: \code{exceptions.Exception}

\end{fulllineitems}

\index{TransferExeption}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.TransferExeption}\pysigline{\strong{exception }\code{RRtoolbox.lib.root.}\bfcode{TransferExeption}}
Bases: \code{exceptions.Exception}

\end{fulllineitems}

\index{VariableNotDeletable}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.VariableNotDeletable}\pysigline{\strong{exception }\code{RRtoolbox.lib.root.}\bfcode{VariableNotDeletable}}
Bases: \code{exceptions.Exception}

\end{fulllineitems}

\index{VariableNotSettable}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.VariableNotSettable}\pysigline{\strong{exception }\code{RRtoolbox.lib.root.}\bfcode{VariableNotSettable}}
Bases: \code{exceptions.Exception}

\end{fulllineitems}

\index{addto() (in module RRtoolbox.lib.root)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.addto}\pysiglinewithargsret{\code{RRtoolbox.lib.root.}\bfcode{addto}}{\emph{instance}, \emph{funcname=None}}{}
Decorator: Add function as method to instance.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{instance}} -- class instance.

\item {} 
\textbf{\texttt{funcname}} -- name to register in instance.

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{decorateInstanceMethods() (in module RRtoolbox.lib.root)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.decorateInstanceMethods}\pysiglinewithargsret{\code{RRtoolbox.lib.root.}\bfcode{decorateInstanceMethods}}{\emph{self}, \emph{decorator}, \emph{excludeMth='\_\_init\_\_'}, \emph{includeMth=None}}{}
Decorate methods in an instance. It should be used in the \_\_init\_\_ method of a class.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{self}} -- class instance.

\item {} 
\textbf{\texttt{decorator}} -- decorator function to apply to self.

\item {} 
\textbf{\texttt{excludeMth}} -- list of methods to exclude.

\item {} 
\textbf{\texttt{includeMth}} -- list of methods to include if not in exclude.
if excludeMth is None then decorateInstanceMethods checks for includeMth list.
if includeMth and excludeMth is None then all methods of self are decorated.

\end{itemize}

\item[{Returns}] \leavevmode
self

\end{description}\end{quote}

\begin{notice}{note}{Note:}
It must be used at instance initialization (i.e. inside \_\_init\_\_ method)
\end{notice}

\end{fulllineitems}

\index{ensureList() (in module RRtoolbox.lib.root)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.ensureList}\pysiglinewithargsret{\code{RRtoolbox.lib.root.}\bfcode{ensureList}}{\emph{obj}}{}
ensures that object is list

\end{fulllineitems}

\index{formatConsume() (in module RRtoolbox.lib.root)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.formatConsume}\pysiglinewithargsret{\code{RRtoolbox.lib.root.}\bfcode{formatConsume}}{\emph{format\_string}, \emph{kwargs}, \emph{formatter=None}, \emph{handle=None}}{}
Format with dictionary and consume keys.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{format\_string}} -- string to format

\item {} 
\textbf{\texttt{kwargs}} -- dictionary containing the keys and values to format string.
The keys must be supported by the string formatter

\item {} 
\textbf{\texttt{formatter}} -- (None) formatter function to format string

\end{itemize}

\item[{Returns}] \leavevmode
formatted string

\end{description}\end{quote}

\end{fulllineitems}

\index{formatOnly() (in module RRtoolbox.lib.root)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.formatOnly}\pysiglinewithargsret{\code{RRtoolbox.lib.root.}\bfcode{formatOnly}}{\emph{format\_string}, \emph{**kwargs}}{}
Format string only with provided keys
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{format\_string}} -- string to format

\item {} 
\textbf{\texttt{kwargs}} -- format keys

\end{itemize}

\item[{Returns}] \leavevmode
formatted string

\end{description}\end{quote}

\end{fulllineitems}

\index{glob() (in module RRtoolbox.lib.root)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.glob}\pysiglinewithargsret{\code{RRtoolbox.lib.root.}\bfcode{glob}}{\emph{path}, \emph{contents='*'}, \emph{check=\textless{}function isfile\textgreater{}}}{}
Return a list of paths matching a pathname pattern with valid files.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{path}} -- path to process ing glob filter

\item {} 
\textbf{\texttt{contents}} -- If path is a folder then looks for contents using

\item {} 
\textbf{\texttt{check}} -- function to filter contents. it must receive the path
and return True to let it pass and False to suppress it.

\end{itemize}

\item[{Returns}] \leavevmode
return list of files

\end{description}\end{quote}

\end{fulllineitems}

\index{globFilter (class in RRtoolbox.lib.root)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.globFilter}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.root.}\bfcode{globFilter}}{\emph{include=None}, \emph{exclude=None}, \emph{case=False}}{}
Bases: \code{object}

glob filter for patterns

\end{fulllineitems}

\index{lookinglob() (in module RRtoolbox.lib.root)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.lookinglob}\pysiglinewithargsret{\code{RRtoolbox.lib.root.}\bfcode{lookinglob}}{\emph{pattern}, \emph{path=None}, \emph{ext=None}, \emph{forward=None}, \emph{filelist=None}, \emph{aslist=False}, \emph{raiseErr=False}}{}
Look for patterns in Path. It looks as \{if path\}\{if pattern\}\{if forward\}\{if ext\}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{pattern}} -- string to look for pattern.

\item {} 
\textbf{\texttt{path}} -- (None) path to look for pattern

\item {} 
\textbf{\texttt{ext}} -- (None) extension of pattern in path

\item {} 
\textbf{\texttt{forward}} -- (None) look changes after pattern and before ext parameter.

\item {} 
\textbf{\texttt{filelist}} -- (None) simulates the files in path and look patterns in this list.

\item {} 
\textbf{\texttt{aslist}} -- (False) if False it returns the first match case string
else the list of matching cases.

\item {} 
\textbf{\texttt{raiseErr}} -- If true raises Exception if patter is not found in path or there
are more than one match

\end{itemize}

\item[{Returns}] \leavevmode
matched case if returnAll is False else the list of matched cases
or if no match is found None

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{RRtoolbox.lib.serverServices module}
\label{RRtoolbox.lib:rrtoolbox-lib-serverservices-module}\label{RRtoolbox.lib:module-RRtoolbox.lib.serverServices}\index{RRtoolbox.lib.serverServices (module)}\index{Conection (class in RRtoolbox.lib.serverServices)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.serverServices.Conection}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.serverServices.}\bfcode{Conection}}{\emph{conn}}{}
represent a connection to interchange objects between servers and clients.
\index{getLen() (RRtoolbox.lib.serverServices.Conection method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.serverServices.Conection.getLen}\pysiglinewithargsret{\bfcode{getLen}}{\emph{timeout=None}}{}
\end{fulllineitems}

\index{rcv() (RRtoolbox.lib.serverServices.Conection method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.serverServices.Conection.rcv}\pysiglinewithargsret{\bfcode{rcv}}{}{}
\end{fulllineitems}

\index{recvall() (RRtoolbox.lib.serverServices.Conection method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.serverServices.Conection.recvall}\pysiglinewithargsret{\bfcode{recvall}}{}{}
\end{fulllineitems}

\index{send() (RRtoolbox.lib.serverServices.Conection method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.serverServices.Conection.send}\pysiglinewithargsret{\bfcode{send}}{\emph{obj}}{}
\end{fulllineitems}

\index{sendLen() (RRtoolbox.lib.serverServices.Conection method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.serverServices.Conection.sendLen}\pysiglinewithargsret{\bfcode{sendLen}}{\emph{length}, \emph{timeout=None}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{generateServer() (in module RRtoolbox.lib.serverServices)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.serverServices.generateServer}\pysiglinewithargsret{\code{RRtoolbox.lib.serverServices.}\bfcode{generateServer}}{\emph{host='localhost'}, \emph{to=63342}}{}
generates a simple Server in available address.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{to}} -- until port.

\item[{Returns}] \leavevmode
socket, address

\end{description}\end{quote}

\end{fulllineitems}

\index{initClient() (in module RRtoolbox.lib.serverServices)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.serverServices.initClient}\pysiglinewithargsret{\code{RRtoolbox.lib.serverServices.}\bfcode{initClient}}{\emph{addr}, \emph{timeout=None}}{}
Inits a simple client from address.
:param addr: (host, port)
:return: socket

\end{fulllineitems}

\index{initServer() (in module RRtoolbox.lib.serverServices)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.serverServices.initServer}\pysiglinewithargsret{\code{RRtoolbox.lib.serverServices.}\bfcode{initServer}}{\emph{addr}}{}
Inits a simple server from address.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{addr}} -- (host, port)

\item[{Returns}] \leavevmode
socket

\end{description}\end{quote}

\end{fulllineitems}

\index{parseString() (in module RRtoolbox.lib.serverServices)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.serverServices.parseString}\pysiglinewithargsret{\code{RRtoolbox.lib.serverServices.}\bfcode{parseString}}{\emph{string}, \emph{timeout=3}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{string}} -- 

\item {} 
\textbf{\texttt{timeout}} -- 

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{ping() (in module RRtoolbox.lib.serverServices)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.serverServices.ping}\pysiglinewithargsret{\code{RRtoolbox.lib.serverServices.}\bfcode{ping}}{\emph{host}, \emph{port}}{}
Ping to.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{host}} -- IP address

\item {} 
\textbf{\texttt{port}} -- port address

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{rcvPickle() (in module RRtoolbox.lib.serverServices)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.serverServices.rcvPickle}\pysiglinewithargsret{\code{RRtoolbox.lib.serverServices.}\bfcode{rcvPickle}}{\emph{addr=(`localhost'}, \emph{50007)}, \emph{timeout=None}}{}
Receive potentially any data using sockets.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{addr}} -- socket or address.

\item {} 
\textbf{\texttt{timeout}} -- NotImplemented

\end{itemize}

\item[{Returns}] \leavevmode
data, else throws error.

\end{description}\end{quote}

\end{fulllineitems}

\index{recv\_into() (in module RRtoolbox.lib.serverServices)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.serverServices.recv_into}\pysiglinewithargsret{\code{RRtoolbox.lib.serverServices.}\bfcode{recv\_into}}{\emph{viewable}, \emph{socket}}{}
Receive from socket into viewable object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{viewable}} -- viewable object

\item {} 
\textbf{\texttt{socket}} -- source socket

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{scan\_ports() (in module RRtoolbox.lib.serverServices)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.serverServices.scan_ports}\pysiglinewithargsret{\code{RRtoolbox.lib.serverServices.}\bfcode{scan\_ports}}{\emph{host}}{}
Scan opened ports in address.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{host}} -- host IP to filter opened ports.

\item[{Returns}] \leavevmode
generator

\end{description}\end{quote}

\end{fulllineitems}

\index{sendPickle() (in module RRtoolbox.lib.serverServices)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.serverServices.sendPickle}\pysiglinewithargsret{\code{RRtoolbox.lib.serverServices.}\bfcode{sendPickle}}{\emph{obj}, \emph{addr=(`localhost'}, \emph{50007)}, \emph{timeout=None}, \emph{threaded=False}}{}
Send potentially any data using sockets.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{obj}} -- packable object.

\item {} 
\textbf{\texttt{addr}} -- socket or address.

\item {} 
\textbf{\texttt{timeout}} -- NotImplemented

\end{itemize}

\item[{Returns}] \leavevmode
True if sent successfully, else Throw error.

\end{description}\end{quote}

\end{fulllineitems}

\index{send\_from() (in module RRtoolbox.lib.serverServices)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.serverServices.send_from}\pysiglinewithargsret{\code{RRtoolbox.lib.serverServices.}\bfcode{send\_from}}{\emph{viewable}, \emph{socket}}{}
Send from viewable object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{viewable}} -- viewable object

\item {} 
\textbf{\texttt{socket}} -- destine socket

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{string\_is\_socket\_address() (in module RRtoolbox.lib.serverServices)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.serverServices.string_is_socket_address}\pysiglinewithargsret{\code{RRtoolbox.lib.serverServices.}\bfcode{string\_is\_socket\_address}}{\emph{string}}{}
\end{fulllineitems}



\subsubsection{RRtoolbox.lib.session module}
\label{RRtoolbox.lib:module-RRtoolbox.lib.session}\label{RRtoolbox.lib:rrtoolbox-lib-session-module}\index{RRtoolbox.lib.session (module)}
This module have serializing methods for data persistence so to let the package ``save'' custom objects

session module made by Davtoh and powered by dill
Dependency project: \href{https://github.com/uqfoundation/dill}{https://github.com/uqfoundation/dill}
\index{checkFromSession() (in module RRtoolbox.lib.session)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.session.checkFromSession}\pysiglinewithargsret{\code{RRtoolbox.lib.session.}\bfcode{checkFromSession}}{\emph{filepath}, \emph{varlist}}{}
Check that variables exits in session file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{filepath}} -- path to session file.

\item {} 
\textbf{\texttt{varlist}} -- list of variables to checkLoaded.

\end{itemize}

\item[{Returns}] \leavevmode
list checkLoaded results

\end{description}\end{quote}

\end{fulllineitems}

\index{deleteFromSession() (in module RRtoolbox.lib.session)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.session.deleteFromSession}\pysiglinewithargsret{\code{RRtoolbox.lib.session.}\bfcode{deleteFromSession}}{\emph{filepath}, \emph{varlist}}{}
Delete variables from session file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{filepath}} -- path to session file.

\item {} 
\textbf{\texttt{varlist}} -- list of variables to delete.

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{flushSession() (in module RRtoolbox.lib.session)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.session.flushSession}\pysiglinewithargsret{\code{RRtoolbox.lib.session.}\bfcode{flushSession}}{\emph{filepath}}{}
Empty session in file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{filepath}} -- path to session file.

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{getEnviromentSession() (in module RRtoolbox.lib.session)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.session.getEnviromentSession}\pysiglinewithargsret{\code{RRtoolbox.lib.session.}\bfcode{getEnviromentSession}}{\emph{enviroment=None}}{}
Gets the filtered session from the global variables.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
dictionary containing filtered session.

\end{description}\end{quote}

\end{fulllineitems}

\index{readSession() (in module RRtoolbox.lib.session)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.session.readSession}\pysiglinewithargsret{\code{RRtoolbox.lib.session.}\bfcode{readSession}}{\emph{filepath}, \emph{helper=None}}{}
Loads a dictionary session from file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{filepath}} -- path to load session file.

\item {} 
\textbf{\texttt{helper}} -- function to pos-process session file

\end{itemize}

\item[{Returns}] \leavevmode
session

\end{description}\end{quote}

\end{fulllineitems}

\index{saveSession() (in module RRtoolbox.lib.session)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.session.saveSession}\pysiglinewithargsret{\code{RRtoolbox.lib.session.}\bfcode{saveSession}}{\emph{filepath}, \emph{session}, \emph{helper=None}}{}
Saves dictionary session to file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{filepath}} -- path to save session file.

\item {} 
\textbf{\texttt{session}} -- dictionary

\item {} 
\textbf{\texttt{helper}} -- function to pre-process session

\end{itemize}

\item[{Returns}] \leavevmode
filename of saved session

\end{description}\end{quote}

\end{fulllineitems}

\index{updateSession() (in module RRtoolbox.lib.session)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.session.updateSession}\pysiglinewithargsret{\code{RRtoolbox.lib.session.}\bfcode{updateSession}}{\emph{filepath}, \emph{session}, \emph{replace=True}, \emph{rdhelper=None}, \emph{svhelper=None}}{}
Updates a dictionary session in file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{filepath}} -- path to session file.

\item {} 
\textbf{\texttt{session}} -- dictionary.

\item {} 
\textbf{\texttt{replace}} -- if True key values are replaced else old key values ar kept.

\item {} 
\textbf{\texttt{rdhelper}} -- read helper.

\item {} 
\textbf{\texttt{svhelper}} -- save helper.

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{Module contents}
\label{RRtoolbox.lib:module-RRtoolbox.lib}\label{RRtoolbox.lib:module-contents}\index{RRtoolbox.lib (module)}
This module contains core-like, too-much-used and too-much-referenced modules


\subsection{RRtoolbox.tools package}
\label{RRtoolbox.tools::doc}\label{RRtoolbox.tools:rrtoolbox-tools-package}

\subsubsection{Submodules}
\label{RRtoolbox.tools:submodules}

\subsubsection{RRtoolbox.tools.lens module}
\label{RRtoolbox.tools:rrtoolbox-tools-lens-module}\label{RRtoolbox.tools:module-RRtoolbox.tools.lens}\index{RRtoolbox.tools.lens (module)}\index{drawCircle() (in module RRtoolbox.tools.lens)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.lens.drawCircle}\pysiglinewithargsret{\code{RRtoolbox.tools.lens.}\bfcode{drawCircle}}{\emph{array}, \emph{cnt}, \emph{color=0}}{}
project circle over array.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{array}} -- array to draw circle

\item {} 
\textbf{\texttt{cnt}} -- contours of segmentation to fit circle

\item {} 
\textbf{\texttt{color}} -- color of lens

\end{itemize}

\item[{Returns}] \leavevmode
array

\end{description}\end{quote}

\end{fulllineitems}

\index{drawEllipse() (in module RRtoolbox.tools.lens)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.lens.drawEllipse}\pysiglinewithargsret{\code{RRtoolbox.tools.lens.}\bfcode{drawEllipse}}{\emph{array}, \emph{cnt}, \emph{color=0}}{}
project ellipse over array.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{array}} -- array to draw ellipse

\item {} 
\textbf{\texttt{cnt}} -- contours of segmentation to fit ellipse

\item {} 
\textbf{\texttt{color}} -- color of lens

\end{itemize}

\item[{Returns}] \leavevmode
array

\end{description}\end{quote}

\end{fulllineitems}

\index{fitLens() (in module RRtoolbox.tools.lens)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.lens.fitLens}\pysiglinewithargsret{\code{RRtoolbox.tools.lens.}\bfcode{fitLens}}{\emph{img}, \emph{mask}, \emph{color=0}, \emph{asEllipse=False}, \emph{addmask=False}}{}
Place lens-like object in image.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{img}} -- image to place lens

\item {} 
\textbf{\texttt{mask}} -- mask to fit lens

\item {} 
\textbf{\texttt{color}} -- color of the lens

\item {} 
\textbf{\texttt{asEllipse}} -- True to fit lens as a ellipse, False to fit circle.

\item {} 
\textbf{\texttt{addmask}} -- return additional mask parameter

\end{itemize}

\item[{Returns}] \leavevmode
image with simulated lens

\end{description}\end{quote}

\end{fulllineitems}

\index{simulateLens() (in module RRtoolbox.tools.lens)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.lens.simulateLens}\pysiglinewithargsret{\code{RRtoolbox.tools.lens.}\bfcode{simulateLens}}{\emph{img}, \emph{threshfunc=None}, \emph{pshape=(300}, \emph{300)}, \emph{color=0}, \emph{asEllipse=True}}{}
Place lens-like object in image.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{img}} -- image to place lens.

\item {} 
\textbf{\texttt{threshfunc}} -- function to segment retinal area and get its mask.

\item {} 
\textbf{\texttt{pshape}} -- shape to resize processing image to increase performance.

\item {} 
\textbf{\texttt{color}} -- color of the lens.

\item {} 
\textbf{\texttt{asEllipse}} -- True to fit lens as a ellipse, False to fit circle.

\end{itemize}

\item[{Returns}] \leavevmode
image with simulated lens.

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{RRtoolbox.tools.segmentation module}
\label{RRtoolbox.tools:rrtoolbox-tools-segmentation-module}\label{RRtoolbox.tools:module-RRtoolbox.tools.segmentation}\index{RRtoolbox.tools.segmentation (module)}\index{find\_optic\_disc\_watershed() (in module RRtoolbox.tools.segmentation)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.segmentation.find_optic_disc_watershed}\pysiglinewithargsret{\code{RRtoolbox.tools.segmentation.}\bfcode{find\_optic\_disc\_watershed}}{\emph{img}, \emph{P}}{}
Find optic disk in image using a watershed method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{img}} -- BGR image

\item {} 
\textbf{\texttt{P}} -- gray image

\end{itemize}

\item[{Returns}] \leavevmode
optic\_disc, Crs, markers, watershed

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_beta\_params\_Otsu() (in module RRtoolbox.tools.segmentation)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.segmentation.get_beta_params_Otsu}\pysiglinewithargsret{\code{RRtoolbox.tools.segmentation.}\bfcode{get\_beta\_params\_Otsu}}{\emph{P}}{}
Automatically find parameters for alpha masks using Otsu threshold value.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{P}} -- gray image

\item[{Returns}] \leavevmode
beta1 for minimum histogram value, beta2 for Otsu value

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_beta\_params\_hist() (in module RRtoolbox.tools.segmentation)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.segmentation.get_beta_params_hist}\pysiglinewithargsret{\code{RRtoolbox.tools.segmentation.}\bfcode{get\_beta\_params\_hist}}{\emph{P}}{}
Automatically find parameters for bright alpha masks
using a histogram analysis method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{P}} -- gray image

\item[{Returns}] \leavevmode
beta1 for minimum valley left of body, beta2 for brightest valley right of body
where the body starts at the tallest peak in the histogram.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_bright\_alpha() (in module RRtoolbox.tools.segmentation)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.segmentation.get_bright_alpha}\pysiglinewithargsret{\code{RRtoolbox.tools.segmentation.}\bfcode{get\_bright\_alpha}}{\emph{backgray}, \emph{foregray}, \emph{window=None}}{}
Get alpha transparency for merging foreground to
background gray image according to brightness.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{backgray}} -- background image. (as float)

\item {} 
\textbf{\texttt{foregray}} -- foreground image. (as float)

\item {} 
\textbf{\texttt{window}} -- window used to customizing alfa. It can be a binary or alpha mask,
values go from 0 for transparency to any value where the maximum is visible
i.e a window with all the same values does nothing. A binary mask can be used,
where 0 is transparent and 1 is visible. If not window is given alfa is not
altered and the intended alpha is returned.

\end{itemize}

\item[{Returns}] \leavevmode
alfa mask

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_layered\_alpha() (in module RRtoolbox.tools.segmentation)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.segmentation.get_layered_alpha}\pysiglinewithargsret{\code{RRtoolbox.tools.segmentation.}\bfcode{get\_layered\_alpha}}{\emph{back}, \emph{fore}}{}
Get bright alpha mask (using Otsu method)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{back}} -- BGR background image

\item {} 
\textbf{\texttt{fore}} -- BGR foreground image

\end{itemize}

\item[{Returns}] \leavevmode
alpha mask

\end{description}\end{quote}

\end{fulllineitems}

\index{layeredfloods() (in module RRtoolbox.tools.segmentation)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.segmentation.layeredfloods}\pysiglinewithargsret{\code{RRtoolbox.tools.segmentation.}\bfcode{layeredfloods}}{\emph{img}, \emph{gray=None}, \emph{backmask=None}, \emph{step=1}, \emph{connectivity=4}, \emph{weight=False}}{}
Create an alpha mask from an image using a weighted layered flooding algorithm,
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{img}} -- BGR image

\item {} 
\textbf{\texttt{gray}} -- Gray image

\item {} 
\textbf{\texttt{backmask}} -- background mask

\item {} 
\textbf{\texttt{step}} -- step to increase upDiff in the floodFill algorithm. If weight is True
step also increases the weight of the layers.

\item {} 
\textbf{\texttt{connectivity}} -- pixel connectivity of 4 or 8 to use in the floodFill algorithm

\item {} 
\textbf{\texttt{weight}} -- Increase progressively the weight of the layers using the step parameter.

\end{itemize}

\item[{Returns}] \leavevmode
alpha mask

\end{description}\end{quote}

\end{fulllineitems}

\index{retina\_markers\_thresh() (in module RRtoolbox.tools.segmentation)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.segmentation.retina_markers_thresh}\pysiglinewithargsret{\code{RRtoolbox.tools.segmentation.}\bfcode{retina\_markers\_thresh}}{\emph{P}}{}
Retinal markers thresholds to find background,
retinal area and optic disc with flares based
in the histogram.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{P}} -- gray image

\item[{Returns}] \leavevmode
min,b1,b2,max

\end{description}\end{quote}

\end{fulllineitems}

\index{retinal\_mask() (in module RRtoolbox.tools.segmentation)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.segmentation.retinal_mask}\pysiglinewithargsret{\code{RRtoolbox.tools.segmentation.}\bfcode{retinal\_mask}}{\emph{img}, \emph{biggest=False}, \emph{addalpha=False}}{}
Obtain the mask of the retinal area in an image.
For a simpler and lightweight algorithm see {\hyperref[RRtoolbox.tools:RRtoolbox.tools.segmentation.retinal_mask_watershed]{\emph{\code{retinal\_mask\_watershed()}}}}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{img}} -- BGR or gray image

\item {} 
\textbf{\texttt{biggest}} -- True to return only biggest object

\item {} 
\textbf{\texttt{addalpha}} -- True to add additional alpha mask parameter

\end{itemize}

\item[{Returns}] \leavevmode
\begin{description}
\item[{if addalpha:}] \leavevmode
binary mask, alpha mask

\item[{else:}] \leavevmode
binary mask

\end{description}


\end{description}\end{quote}

\end{fulllineitems}

\index{retinal\_mask\_watershed() (in module RRtoolbox.tools.segmentation)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.segmentation.retinal_mask_watershed}\pysiglinewithargsret{\code{RRtoolbox.tools.segmentation.}\bfcode{retinal\_mask\_watershed}}{\emph{img}, \emph{parameters=(10}, \emph{30}, \emph{None)}, \emph{addMarkers=False}}{}
Quick and simple watershed method to obtain the mask of the retinal area in an image.
For a more robust algorithm see {\hyperref[RRtoolbox.tools:RRtoolbox.tools.segmentation.retinal_mask]{\emph{\code{retinal\_mask()}}}}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{img}} -- BGR or gray image

\item {} 
\textbf{\texttt{parameters}} -- tuple of parameters to pass to \code{filterFactory()}

\item {} 
\textbf{\texttt{addMarkers}} -- True to add additional Marker mask. It contains 0 for unknown
areas, 1 for background and 2 for retinal area.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{description}
\item[{if addMarkers:}] \leavevmode
binary mask, Markers mask

\item[{else:}] \leavevmode
binary mask

\end{description}


\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{RRtoolbox.tools.selectors module}
\label{RRtoolbox.tools:module-RRtoolbox.tools.selectors}\label{RRtoolbox.tools:rrtoolbox-tools-selectors-module}\index{RRtoolbox.tools.selectors (module)}\index{EntropyPlot (class in RRtoolbox.tools.selectors)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.selectors.EntropyPlot}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.tools.selectors.}\bfcode{EntropyPlot}}{\emph{images}, \emph{win='Entropy tests'}, \emph{func=None}}{}
Bases: {\hyperref[RRtoolbox.lib:RRtoolbox.lib.plotter.Plotim]{\emph{\code{RRtoolbox.lib.plotter.Plotim}}}}

Plot entropy test
\index{getData() (RRtoolbox.tools.selectors.EntropyPlot method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.selectors.EntropyPlot.getData}\pysiglinewithargsret{\bfcode{getData}}{\emph{im}}{}
\end{fulllineitems}

\index{getImage() (RRtoolbox.tools.selectors.EntropyPlot method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.selectors.EntropyPlot.getImage}\pysiglinewithargsret{\bfcode{getImage}}{\emph{im}}{}
\end{fulllineitems}

\index{keyfunc() (RRtoolbox.tools.selectors.EntropyPlot method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.selectors.EntropyPlot.keyfunc}\pysiglinewithargsret{\bfcode{keyfunc}}{}{}
\end{fulllineitems}

\index{nextim() (RRtoolbox.tools.selectors.EntropyPlot method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.selectors.EntropyPlot.nextim}\pysiglinewithargsret{\bfcode{nextim}}{}{}
\end{fulllineitems}

\index{previousim() (RRtoolbox.tools.selectors.EntropyPlot method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.selectors.EntropyPlot.previousim}\pysiglinewithargsret{\bfcode{previousim}}{}{}
\end{fulllineitems}

\index{selectlist() (RRtoolbox.tools.selectors.EntropyPlot method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.selectors.EntropyPlot.selectlist}\pysiglinewithargsret{\bfcode{selectlist}}{\emph{imlist}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{entropy() (in module RRtoolbox.tools.selectors)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.selectors.entropy}\pysiglinewithargsret{\code{RRtoolbox.tools.selectors.}\bfcode{entropy}}{\emph{imlist}, \emph{loadfunc=None}, \emph{invert=False}}{}
Entropy function modified from:

Yan Liu, Feihong Yu, An automatic image fusion algorithm for unregistered multiply multi-focus images,
Optics Communications, Volume 341, 15 April 2015, Pages 101-113, ISSN 0030-4018,
\href{http://dx.doi.org/10.1016/j.optcom.2014.12.015}{http://dx.doi.org/10.1016/j.optcom.2014.12.015}.
(\href{http://www.sciencedirect.com/science/article/pii/S0030401814011559}{http://www.sciencedirect.com/science/article/pii/S0030401814011559})
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{imlist}} -- list of path to images or arrays

\item[{Returns}] \leavevmode
sortedD,sortedImlist,D,fns

\end{description}\end{quote}
\begin{description}
\item[{where sortedD is the ranking of the Entropy test, D = {[}D0,...,DN{]} D0\textgreater{}DN}] \leavevmode
sortedImlist is fns sorted to match sortedD,
D is the list of the absolute difference between entropy and the root mean square, D = {\color{red}\bfseries{}\textbar{}E-RMS\textbar{}}

\end{description}

\end{fulllineitems}

\index{hist\_comp() (in module RRtoolbox.tools.selectors)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.selectors.hist_comp}\pysiglinewithargsret{\code{RRtoolbox.tools.selectors.}\bfcode{hist\_comp}}{\emph{imlist}, \emph{loadfunc=None}, \emph{method='correlation'}}{}
Histogram comparison
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{imlist}} -- list of path to images or arrays

\item[{Returns}] \leavevmode
comparison

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{RRtoolbox.tools.sticher module}
\label{RRtoolbox.tools:rrtoolbox-tools-sticher-module}\label{RRtoolbox.tools:module-RRtoolbox.tools.sticher}\index{RRtoolbox.tools.sticher (module)}\index{stich() (in module RRtoolbox.tools.sticher)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.sticher.stich}\pysiglinewithargsret{\code{RRtoolbox.tools.sticher.}\bfcode{stich}}{\emph{**opts}}{}
\end{fulllineitems}



\subsubsection{Module contents}
\label{RRtoolbox.tools:module-contents}\label{RRtoolbox.tools:module-RRtoolbox.tools}\index{RRtoolbox.tools (module)}

\section{Submodules}
\label{RRtoolbox:submodules}

\section{RRtoolbox.core module}
\label{RRtoolbox:module-RRtoolbox.core}\label{RRtoolbox:rrtoolbox-core-module}\index{RRtoolbox.core (module)}\index{f() (in module RRtoolbox.core)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox:RRtoolbox.core.f}\pysiglinewithargsret{\code{RRtoolbox.core.}\bfcode{f}}{\emph{*args}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{rrbox (class in RRtoolbox.core)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox:RRtoolbox.core.rrbox}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.core.}\bfcode{rrbox}}{\emph{*args}}{}
Bases: \code{object}
\index{asift() (RRtoolbox.core.rrbox method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox:RRtoolbox.core.rrbox.asift}\pysiglinewithargsret{\bfcode{asift}}{\emph{fn}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{tools() (in module RRtoolbox.core)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox:RRtoolbox.core.tools}\pysiglinewithargsret{\code{RRtoolbox.core.}\bfcode{tools}}{\emph{instance}, \emph{modules}}{}
\end{fulllineitems}

\index{tools2() (in module RRtoolbox.core)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox:RRtoolbox.core.tools2}\pysiglinewithargsret{\code{RRtoolbox.core.}\bfcode{tools2}}{\emph{instance}, \emph{modules}}{}
\end{fulllineitems}



\section{RRtoolbox.run module}
\label{RRtoolbox:module-RRtoolbox.run}\label{RRtoolbox:rrtoolbox-run-module}\index{RRtoolbox.run (module)}

\section{RRtoolbox.shell module}
\label{RRtoolbox:module-RRtoolbox.shell}\label{RRtoolbox:rrtoolbox-shell-module}\index{RRtoolbox.shell (module)}\index{Shell (class in RRtoolbox.shell)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox:RRtoolbox.shell.Shell}\pysigline{\strong{class }\code{RRtoolbox.shell.}\bfcode{Shell}}~\index{generateParser() (RRtoolbox.shell.Shell method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox:RRtoolbox.shell.Shell.generateParser}\pysiglinewithargsret{\bfcode{generateParser}}{\emph{func}}{}
\end{fulllineitems}

\index{getParser() (RRtoolbox.shell.Shell method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox:RRtoolbox.shell.Shell.getParser}\pysiglinewithargsret{\bfcode{getParser}}{\emph{func}}{}
\end{fulllineitems}

\index{parse() (RRtoolbox.shell.Shell method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox:RRtoolbox.shell.Shell.parse}\pysiglinewithargsret{\bfcode{parse}}{\emph{func}, \emph{args=None}, \emph{namespace=None}}{}
\end{fulllineitems}

\index{parser\_fastplt() (RRtoolbox.shell.Shell method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox:RRtoolbox.shell.Shell.parser_fastplt}\pysiglinewithargsret{\bfcode{parser\_fastplt}}{}{}
\end{fulllineitems}

\index{parser\_loadFunc() (RRtoolbox.shell.Shell method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox:RRtoolbox.shell.Shell.parser_loadFunc}\pysiglinewithargsret{\bfcode{parser\_loadFunc}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{getDocParamLines() (in module RRtoolbox.shell)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox:RRtoolbox.shell.getDocParamLines}\pysiglinewithargsret{\code{RRtoolbox.shell.}\bfcode{getDocParamLines}}{\emph{doc}}{}
gets each parameter line from reStructured doc.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{doc}} -- documentation

\item[{Returns}] \leavevmode
lines

\end{description}\end{quote}

\end{fulllineitems}

\index{getDocParameters() (in module RRtoolbox.shell)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox:RRtoolbox.shell.getDocParameters}\pysiglinewithargsret{\code{RRtoolbox.shell.}\bfcode{getDocParameters}}{\emph{doc}}{}
gets param and comment from reStructured doc.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{doc}} -- documentation

\item[{Returns}] \leavevmode
list of (param,comment) items.

\end{description}\end{quote}

\end{fulllineitems}

\index{shell\_processor() (in module RRtoolbox.shell)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox:RRtoolbox.shell.shell_processor}\pysiglinewithargsret{\code{RRtoolbox.shell.}\bfcode{shell\_processor}}{\emph{commands}}{}
\end{fulllineitems}

\index{shell\_processor\_parser() (in module RRtoolbox.shell)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox:RRtoolbox.shell.shell_processor_parser}\pysiglinewithargsret{\code{RRtoolbox.shell.}\bfcode{shell\_processor\_parser}}{\emph{syslist}, \emph{flags='`}, \emph{longopts=(`feature='}, \emph{`nnn=')}}{}
\end{fulllineitems}

\index{string\_interpreter() (in module RRtoolbox.shell)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox:RRtoolbox.shell.string_interpreter}\pysiglinewithargsret{\code{RRtoolbox.shell.}\bfcode{string\_interpreter}}{\emph{empty=None}, \emph{commahandler=None}, \emph{handle=None}}{}
create a string interpreter
:param empty: (None) variable to handle empty strings
:param commahandler: (tuple\_creator) function to handle comma separated strings
:return: interpreter function

\end{fulllineitems}

\index{tuple\_creator() (in module RRtoolbox.shell)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox:RRtoolbox.shell.tuple_creator}\pysiglinewithargsret{\code{RRtoolbox.shell.}\bfcode{tuple\_creator}}{\emph{string}}{}
Process string to get tuple.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{string}} -- string parameters with '','' (colon) as separator
Ex: param1, param2, ..., paramN

\item[{Returns}] \leavevmode
tuple

\end{description}\end{quote}

\end{fulllineitems}



\section{Module contents}
\label{RRtoolbox:module-RRtoolbox}\label{RRtoolbox:module-contents}\index{RRtoolbox (module)}

\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\DUspan{xref,std,std-ref}{genindex}

\item {} 
\DUspan{xref,std,std-ref}{modindex}

\item {} 
\DUspan{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{r}
\item {\texttt{RRtoolbox}}, \pageref{RRtoolbox:module-RRtoolbox}
\item {\texttt{RRtoolbox.core}}, \pageref{RRtoolbox:module-RRtoolbox.core}
\item {\texttt{RRtoolbox.lib}}, \pageref{RRtoolbox.lib:module-RRtoolbox.lib}
\item {\texttt{RRtoolbox.lib.arrayops}}, \pageref{RRtoolbox.lib.arrayops:module-RRtoolbox.lib.arrayops}
\item {\texttt{RRtoolbox.lib.arrayops.basic}}, \pageref{RRtoolbox.lib.arrayops:module-RRtoolbox.lib.arrayops.basic}
\item {\texttt{RRtoolbox.lib.arrayops.convert}}, \pageref{RRtoolbox.lib.arrayops:module-RRtoolbox.lib.arrayops.convert}
\item {\texttt{RRtoolbox.lib.arrayops.filters}}, \pageref{RRtoolbox.lib.arrayops:module-RRtoolbox.lib.arrayops.filters}
\item {\texttt{RRtoolbox.lib.arrayops.mask}}, \pageref{RRtoolbox.lib.arrayops:module-RRtoolbox.lib.arrayops.mask}
\item {\texttt{RRtoolbox.lib.cache}}, \pageref{RRtoolbox.lib:module-RRtoolbox.lib.cache}
\item {\texttt{RRtoolbox.lib.config}}, \pageref{RRtoolbox.lib:module-RRtoolbox.lib.config}
\item {\texttt{RRtoolbox.lib.descriptors}}, \pageref{RRtoolbox.lib:module-RRtoolbox.lib.descriptors}
\item {\texttt{RRtoolbox.lib.directory}}, \pageref{RRtoolbox.lib:module-RRtoolbox.lib.directory}
\item {\texttt{RRtoolbox.lib.image}}, \pageref{RRtoolbox.lib:module-RRtoolbox.lib.image}
\item {\texttt{RRtoolbox.lib.inspector}}, \pageref{RRtoolbox.lib:module-RRtoolbox.lib.inspector}
\item {\texttt{RRtoolbox.lib.plotter}}, \pageref{RRtoolbox.lib:module-RRtoolbox.lib.plotter}
\item {\texttt{RRtoolbox.lib.root}}, \pageref{RRtoolbox.lib:module-RRtoolbox.lib.root}
\item {\texttt{RRtoolbox.lib.serverServices}}, \pageref{RRtoolbox.lib:module-RRtoolbox.lib.serverServices}
\item {\texttt{RRtoolbox.lib.session}}, \pageref{RRtoolbox.lib:module-RRtoolbox.lib.session}
\item {\texttt{RRtoolbox.run}}, \pageref{RRtoolbox:module-RRtoolbox.run}
\item {\texttt{RRtoolbox.shell}}, \pageref{RRtoolbox:module-RRtoolbox.shell}
\item {\texttt{RRtoolbox.tools}}, \pageref{RRtoolbox.tools:module-RRtoolbox.tools}
\item {\texttt{RRtoolbox.tools.lens}}, \pageref{RRtoolbox.tools:module-RRtoolbox.tools.lens}
\item {\texttt{RRtoolbox.tools.segmentation}}, \pageref{RRtoolbox.tools:module-RRtoolbox.tools.segmentation}
\item {\texttt{RRtoolbox.tools.selectors}}, \pageref{RRtoolbox.tools:module-RRtoolbox.tools.selectors}
\item {\texttt{RRtoolbox.tools.sticher}}, \pageref{RRtoolbox.tools:module-RRtoolbox.tools.sticher}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
\grid
